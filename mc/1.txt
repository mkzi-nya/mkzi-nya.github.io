>>> main.py
#!/usr/bin/env python
# PySimpleGui library: https://pypi.org/project/PySimpleGUI/
import os
import importlib.util

from src.logic import manage_events
from src.window import window_layouts
import multiprocessing
import logging
from src.logger import configure_logging

if __name__ == "__main__":

    configure_logging()
    logging.info("This is the log console. Most events that take place will be shown here")

    # Py Installer SPlash manager
    if '_PYIBoot_SPLASH' in os.environ and importlib.util.find_spec("pyi_splash"):
        import pyi_splash

        pyi_splash.update_text('UI Loaded ...')
        pyi_splash.close()
        logging.info('Splash screen closed.')

    # Enable Multiprocessing to work in executable form
    multiprocessing.freeze_support()
    logging.debug("Multiprocessing freeze_support enabled")

    # Instantiate the window
    window = window_layouts.make_window()
    logging.debug("Window instantiated")

    # Manage all its events
    manage_events.manage_events(window)
    # Finish up by removing from the screen
    window.close()
    logging.warning("The Program has been closed!")


>>> src/cli.py
import sys
import os
import argparse
from typing import Optional, Tuple, List
from datetime import datetime

from tqdm import tqdm

# 复用现有逻辑
from src.logic.image_logic.image_manager import manipulate_image
from src.logic.vid_logic.vid_manager import vid_manager

SUPPORTED_IMG_EXTS = {".png", ".jpg", ".jpeg", ".PNG", ".JPG", ".JPEG"}
SUPPORTED_VIDEO_EXTS = {".mp4", ".mov", ".mkv", ".avi", ".webm", ".m4v"}


# ========== 工具函数 ==========
def wrap_color(name: Optional[str]) -> list:
    return [name] if name else ["Linear Average"]

def wrap_compare(name: Optional[str]) -> list:
    return [name] if name else ["Absolute Difference"]

def parse_crop(crop: Optional[str]) -> Optional[list]:
    if not crop:
        return None
    parts = [p.strip() for p in crop.split(',')]
    if len(parts) != 4:
        raise ValueError('--crop 必须为 "x1,y1,x2,y2"；x2/y2 可用 max')
    return [parts[0] or "0", parts[1] or "0", parts[2] or "Max", parts[3] or "Max"]

def read_blocklist_file(path: Optional[str]) -> List[str]:
    """
    从文本文件读取方块名（黑名单/白名单），一行一个。
    忽略空行与注释行（以 # 或 // 开头）。
    """
    if not path:
        return []
    items: List[str] = []
    with open(path, "r", encoding="utf-8") as f:
        for line in f:
            s = line.strip()
            if not s:
                continue
            if s.startswith("#") or s.startswith("//"):
                continue
            items.append(s)
    return items

def merge_blocklists(list_from_args: Optional[List[str]], list_from_file: Optional[List[str]]) -> List[str]:
    out: List[str] = []
    seen = set()
    for name in (list_from_args or []) + (list_from_file or []):
        if name not in seen:
            out.append(name)
            seen.add(name)
    return out

def list_images_in_dir(d: str) -> List[str]:
    files = []
    for name in sorted(os.listdir(d)):
        p = os.path.join(d, name)
        if os.path.isfile(p) and os.path.splitext(p)[1] in SUPPORTED_IMG_EXTS:
            files.append(p)
    return files

def make_default_output_dir() -> str:
    out_dir = "./mcIVASMAKER_output"
    os.makedirs(out_dir, exist_ok=True)
    return out_dir

def timestamp() -> str:
    return datetime.now().strftime("%y_%m_%d-%H_%M_%S")

def _ext_for_kind(kind: str) -> str:
    """根据 kind 决定默认输出扩展名。"""
    if kind in ('any-image', 'lamps-image'):
        return '.png'
    if kind == 'any-mcs':
        return '.mcstructure'
    # 其余都当作 schem
    return '.schem'

# ========== 图片（单张/目录） ==========
def build_image_details(args) -> dict:
    # 合并黑名单：命令行列表 + 文件
    file_list = read_blocklist_file(args.blocklist_file)
    merged_blocklist = merge_blocklists(args.blocklist or [], file_list)

    return {
        'blocklist': merged_blocklist,
        'mode': args.mode,
        'dither': args.dither,
        'alternate': args.alternate,
        'color_set': wrap_color(args.color_set),
        'color_compare': wrap_compare(args.color_compare),
        'side': args.side.lower(),
        'brightness': args.brightness,
        'place_redstone_blocks': args.place_redstone_blocks
    }

def do_image(args):
    img_type_map = {
        'any-image': 'Image To Any Block Image',
        'any-schem': 'Image To Any Block Schematic',
        'lamps-image': 'Image To Redstone Lamps Image',
        'lamps-schem': 'Image To Redstone Lamps Schematic',
        'any-mcs': 'Image To Any Block MCStructure',   # 新增：MCStructure 输出
    }
    manipulation = img_type_map[args.kind]
    # 直接使用倍数缩放（float）
    scale = args.scale
    details = build_image_details(args)
    crop_val = parse_crop(args.crop)

    # 目录批量模式
    if os.path.isdir(args.input):
        in_dir = args.input
        files = list_images_in_dir(in_dir)
        if not files:
            print(f"[warn] 目录中没有可处理的图片：{in_dir}")
            return

        # 输出目录：若 -o 指向一个目录或以 / 结尾则用之；否则用默认输出目录
        if args.output and (os.path.isdir(args.output) or args.output.endswith(('/', '\\'))):
            out_dir = args.output.rstrip('/\\')
            os.makedirs(out_dir, exist_ok=True)
        else:
            out_dir = make_default_output_dir()

        # 外层进度条：文件维度
        with tqdm(total=len(files), desc="Files", unit="img") as files_bar:
            for in_path in files:
                base = os.path.splitext(os.path.basename(in_path))[0]
                ext = _ext_for_kind(args.kind)  # 使用统一扩展名判断
                out_path = os.path.join(out_dir, f"{base}_{timestamp()}{ext}")
                _run_single_image(in_path, out_path, manipulation, scale, details, crop_val)
                files_bar.update(1)

        print(f"[ok] 全部完成，输出目录：{out_dir}")
        return

    # 单文件模式
    output = args.output
    if not output:
        out_dir = make_default_output_dir()
        ext = _ext_for_kind(args.kind)  # 使用统一扩展名判断
        output = os.path.join(out_dir, f"output{timestamp()}{ext}")

    _run_single_image(args.input, output, manipulation, scale, details, crop_val)
    print(f"[ok] saved to: {output}")

def _run_single_image(in_path: str, out_path: str, manipulation: str, scale: float, details: dict, crop_val: Optional[list]):
    # 内层进度条：列（tile/x）维度
    total_cols = None
    last_x = -1
    pbar = None

    for prog in manipulate_image(
        filepath=in_path,
        output=out_path,
        manipulation=manipulation,
        crop=crop_val,
        scale=scale,  # 直接传倍数（float）
        details=details
    ):
        # 生成器约定：首次 yield int 为总列数/宽度；之后连续 yield 当前列索引 x
        if isinstance(prog, int):
            if total_cols is None:
                total_cols = prog
                pbar = tqdm(total=total_cols, desc=f"Processing {os.path.basename(in_path)}", unit="col")
            else:
                # prog 是当前 x（0..width-1），转换为增量
                delta = (prog - last_x) if last_x >= 0 else 1
                if delta < 0:
                    delta = 0
                pbar.update(delta)
                last_x = prog
        elif prog == "Done Processing!":
            if pbar:
                # 补齐进度条
                remaining = pbar.total - pbar.n
                if remaining > 0:
                    pbar.update(remaining)
                pbar.close()
            print(f"[save] writing file: {os.path.basename(out_path)}")
        elif prog == "Done!":
            break

# ========== 视频（进度条） ==========
def do_video(args):
    vid_type_map = {
        'any-image': 'Video To Any Block Image',
        'any-schem': 'Video To Any Block Schematic',
        'lamps-image': 'Video To Redstone Lamps Image',
        'lamps-schem': 'Video To Redstone Lamps Schematic',
    }
    manipulation = vid_type_map[args.kind]
    scale = args.scale  # 直接倍数（float）

    # 合并黑名单（视频同样适用 Any Block 路径）
    file_list = read_blocklist_file(args.blocklist_file)
    merged_blocklist = merge_blocklists(args.blocklist or [], file_list)

    details = {
        'blocklist': merged_blocklist,
        'mode': args.mode,
        'quality': args.quality,
        'frame_rate': args.fps,
        'dither': args.dither,
        'alternate': args.alternate,
        'color_set': wrap_color(args.color_set),
        'color_compare': wrap_compare(args.color_compare),
        'side': args.side.lower(),
        'brightness': args.brightness,
        'process_count': max(1, min(16, args.processes))
    }

    # —— 决定输出路径：目录→自动命名；文件→强制 .mp4 ——
    out_arg = args.output
    in_dir = os.path.dirname(args.input) or "."
    def _auto_name_mp4(dst_dir: str) -> str:
        os.makedirs(dst_dir, exist_ok=True)
        return os.path.join(dst_dir, f"output{timestamp()}.mp4")

    if not out_arg:
        output = _auto_name_mp4(in_dir)            # 未指定 → 放到原视频目录
    else:
        out_arg = out_arg.rstrip()
        root, ext = os.path.splitext(out_arg)
        if os.path.isdir(out_arg) or out_arg.endswith(('/', '\\')) or ext == "":
            output = _auto_name_mp4(out_arg)       # 目录或无扩展名 → 目录自动命名
        else:
            if ext.lower() != ".mp4":              # 指定了文件名但不是 .mp4 → 改成 .mp4
                print(f"[warn] 输出扩展名 {ext} 非 .mp4，已改为 .mp4")
                output = root + ".mp4"
            else:
                output = out_arg

    # 构造 tqdm 进度条（抽帧 & 处理）
    bars = {
        "extract": None,   # 抽帧（近似用帧总数 * 百分比）
        "process": None,   # 处理（逐帧计数）
    }
    state = {
        "frame_total": None,
        "extract_last": 0.0,
        "process_done": 0
    }

    def cli_progress(ev):
        name, payload = ev
        if name == '-Image_Count-':
            state["frame_total"] = int(payload)
            bars["extract"] = tqdm(total=state["frame_total"], desc="Extract", unit="frame")
            bars["process"] = tqdm(total=state["frame_total"], desc="Process", unit="frame")
        elif name == '-Set_Images_Done-':
            pass
        elif name == '-Img_Conversion-':
            if state["frame_total"] and bars["extract"]:
                pct = float(payload)
                if pct <= 1:
                    target = pct * state["frame_total"]
                    delta = max(0, target - state["extract_last"])
                    bars["extract"].update(delta)
                    state["extract_last"] = target
                else:
                    remaining = bars["extract"].total - bars["extract"].n
                    if remaining > 0:
                        bars["extract"].update(remaining)
        elif name == '-Image_Done-':
            if bars["process"]:
                bars["process"].update(1)
                state["process_done"] += 1
        # 单帧内 0~100 的细颗粒进度不额外画条，避免刷屏

    vid_manager(
        window=None,
        filepath=args.input,
        output=output,
        manipulation=manipulation,
        scale=scale,        # 直接倍数传入；你已在 image_manager 中兼容 float
        details=details,
        progress_cb=cli_progress
    )

    # 收尾
    for key in ("extract", "process"):
        if bars[key]:
            remain = bars[key].total - bars[key].n
            if remain > 0:
                bars[key].update(remain)
            bars[key].close()

    print(f"[ok] saved to: {output}")

# ========== 参数解析 ==========
def build_parser():
    p = argparse.ArgumentParser(prog='mcIVASMaker', description='Minecraft Image/Video AnyBlock/Lamps Converter (CLI)')
    sub = p.add_subparsers(dest='cmd', required=True)

    def common_block_args(sp):
        sp.add_argument('--side', default='top', choices=['top','bottom','north','south','east','west'], help='采样方位（方块贴图朝向）')
        sp.add_argument('--mode', default='All', choices=['All','Whitelist','Blacklist'], help='筛选模式')
        sp.add_argument('--blocklist', nargs='*', help='白/黑名单的方块名列表（与资源键一致）')
        sp.add_argument('--blocklist-file', help='从文本文件读取黑名单/白名单，每行一个，支持注释行(# 或 //)')
        sp.add_argument('--color-set', help='颜色聚合方式，如 "Linear Average"/"RMS Average"/"HSL"/"HSV"/"Lab"/"Dominant"（依据资源数据命名）')
        sp.add_argument('--color-compare', help='颜色差异算法，如 "Absolute Difference"/"Euclidean Difference"/"Weighted Euclidean"/"Redmean Difference"/"CIE76 DelE"')

    # image
    pi = sub.add_parser('image', help='处理单张图片或目录（目录将批量处理）')
    pi.add_argument('kind', choices=['any-image','any-schem','lamps-image','lamps-schem','any-mcs'], help='输出类型')
    pi.add_argument('-i','--input', required=True, help='输入图片路径或目录')
    pi.add_argument('-o','--output', help='输出文件或目录（目录模式下建议指定为目录；默认 ./mcIVASMAKER_output）')
    pi.add_argument('--scale', type=float, default=1.0, help='缩放倍数（1.0=原图分辨率，0.5=一半，2.0=两倍）')
    pi.add_argument('--crop', help='裁剪区域：x1,y1,x2,y2；x2/y2 可用 max')
    pi.add_argument('--brightness', type=int, default=127, help='Lamps 模式阈值（0~255）')
    pi.add_argument('--dither', action='store_true', help='Lamps 使用抖动')
    pi.add_argument('--alternate', action='store_true', help='Lamps 使用 alternate 模式')
    pi.add_argument('--place-redstone-blocks', action='store_true', help='Lamps schematic 在灯下放置红石块')
    common_block_args(pi)
    pi.set_defaults(func=do_image)

    # video
    pv = sub.add_parser('video', help='处理视频')
    pv.add_argument('kind', choices=['any-image','any-schem','lamps-image','lamps-schem'], help='输出类型')
    pv.add_argument('-i','--input', required=True, help='输入视频路径')
    pv.add_argument('-o','--output', help='输出文件路径（默认放到 ./mcIVASMAKER_output）')
    pv.add_argument('--scale', type=float, default=1.0, help='缩放倍数（1.0=原尺寸，0.5=一半，2.0=两倍）')
    pv.add_argument('--fps', type=int, default=12, help='抽帧帧率（与 GUI 滑条一致）')
    pv.add_argument('--quality', action='store_true', help='使用 PNG 中间帧（更高质量更慢）；不指定则使用 JPG')
    pv.add_argument('--brightness', type=int, default=127, help='Lamps 模式阈值')
    pv.add_argument('--dither', action='store_true', help='Lamps 使用抖动')
    pv.add_argument('--alternate', action='store_true', help='Lamps 使用 alternate 模式')
    pv.add_argument('--processes', type=int, default=2, help='并行处理进程数（1~16）')
    common_block_args(pv)
    pv.set_defaults(func=do_video)

    return p

def main(argv=None):
    argv = argv if argv is not None else sys.argv[1:]
    # === 简化模式：python -m src.cli <输入> <倍数> [输出(可为目录或文件)] ===
    if len(argv) >= 2 and os.path.exists(argv[0]):
        in_path = argv[0]
        try:
            scale_val = float(argv[1])
        except ValueError:
            scale_val = None

        if scale_val is not None:
            out_arg = argv[2] if len(argv) >= 3 else None
            if len(argv) >= 4:
                print("[warn] 额外参数已忽略：", " ".join(argv[3:]))

            ext = os.path.splitext(in_path)[1].lower()
            is_video = ext in SUPPORTED_VIDEO_EXTS
            in_dir = os.path.dirname(in_path) or "."

            # —— 统一构造输出路径（目录→自动命名；文件→强制扩展名） ——
            def _auto_name(dst_dir: str, suffix: str) -> str:
                os.makedirs(dst_dir, exist_ok=True)
                return os.path.join(dst_dir, f"output{timestamp()}{suffix}")

            if not out_arg:
                output_path = _auto_name(in_dir, ".mp4" if is_video else ".png")
            else:
                out_arg = out_arg.rstrip()
                root, ext_o = os.path.splitext(out_arg)
                if os.path.isdir(out_arg) or out_arg.endswith(('/', '\\')) or ext_o == "":
                    output_path = _auto_name(out_arg, ".mp4" if is_video else ".png")
                else:
                    # 指定了具体文件名 → 强制正确扩展名
                    need = ".mp4" if is_video else ".png"
                    if ext_o.lower() != need:
                        print(f"[warn] 输出扩展名 {ext_o} 非 {need}，已改为 {need}")
                        output_path = root + need
                    else:
                        output_path = out_arg

            # 保护：避免覆盖输入
            if os.path.abspath(in_path) == os.path.abspath(output_path):
                fallback = _auto_name("./mcIVASMAKER_output", ".mp4" if is_video else ".png")
                print(f"[warn] 输出与输入相同，已改为：{fallback}")
                output_path = fallback

            if is_video:
                # —— 构造简单视频参数并调用 do_video ——
                class SimpleArgsV:
                    kind = 'any-image'     # 视频默认：任意方块视频
                    input = in_path
                    output = output_path
                    scale = scale_val
                    fps = 12
                    quality = False
                    brightness = 127
                    dither = False
                    alternate = False
                    processes = 2
                    side = 'top'
                    mode = 'All'
                    blocklist = []
                    blocklist_file = None
                    color_set = None
                    color_compare = None
                do_video(SimpleArgsV())
            else:
                # —— 构造简单图片参数并调用 do_image ——
                class SimpleArgsI:
                    kind = 'any-image'     # 图片默认：任意方块图片
                    input = in_path
                    output = output_path
                    scale = scale_val
                    crop = None
                    brightness = 127
                    dither = False
                    alternate = False
                    place_redstone_blocks = False
                    side = 'top'
                    mode = 'All'
                    blocklist = []
                    blocklist_file = None
                    color_set = None
                    color_compare = None
                do_image(SimpleArgsI())
            return

    # === 正常模式 ===
    parser = build_parser()
    args = parser.parse_args(argv)
    args.func(args)

if __name__ == '__main__':
    main()

>>> src/logger.py
import logging
import time
import os


def configure_logging():
    # Not using resource_path here, because I want it to be seen outside the executable
    if not os.path.exists("./mcIVASMAKER_logs"):
        os.makedirs("./mcIVASMAKER_logs")
    logging.basicConfig(
        filename=f"./mcIVASMAKER_logs/Log{time.strftime('%y_%m_%d-%H_%M_%S', time.localtime())}.log",
        format="{asctime:s}::{name:s}_[{levelname:^8s}] - {message:s}",
        datefmt='%Y/%m/%d %I:%M:%S%p',
        style='{',
        encoding='utf-8',
        level=logging.DEBUG
    )
    console = logging.StreamHandler()
    console.setLevel(logging.INFO)
    console.setFormatter(logging.Formatter(
        "{asctime:s}::{name:s}_[{levelname:^8s}] - {message:s}",
        style="{",
        datefmt='%Y/%m/%d %I:%M:%S%p'
    ))
    # add the handler to the root logger
    logging.getLogger('').addHandler(console)
    logging.getLogger("PIL.PngImagePlugin").setLevel(logging.CRITICAL + 1)


>>> src/main_cli.py
# CLI version of the program (Recommended for larger images/multiple images/automation)
# TODO
print("This is not completed yet!")

>>> src/logic/color_averager.py
from PIL import Image, ImageCms
import colorsys
import math
import numpy as np


# Everything is stored as rgb, just conversions are different
def linear_avg_rgb(image: Image.Image) -> list:
    avg_color = [0, 0, 0, 0]
    counter = 0
    for i in range(image.width):
        for j in range(image.height):
            pixel = image.getpixel((i, j))
            for k in range(4):
                avg_color[k] += pixel[k]
            counter += 1

    return [round(avg_color[i] / counter) for i in range(4)]


# sqrt((R1^2+R2^2)/2),sqrt((G1^2+G2^2)/2),sqrt((B1^2+B2^2)/2)
def rms_rgb_color(image: Image.Image) -> list:
    average_red = 0.0
    average_green = 0.0
    average_blue = 0.0
    average_alpha = 0.0
    for x in range(image.width):
        for y in range(image.height):
            pixel = image.getpixel((x, y))
            average_red += pixel[0] * pixel[0]
            average_green += pixel[1] * pixel[1]
            average_blue += pixel[2] * pixel[2]
            average_alpha += pixel[3] * pixel[3]

    average_red = average_red / (image.width * image.height)
    average_green = average_green / (image.width * image.height)
    average_blue = average_blue / (image.width * image.height)
    average_alpha = average_alpha / (image.width * image.height)
    return [round(average_red ** 0.5), round(average_green ** 0.5), round(average_blue ** 0.5),
            round(average_alpha ** 0.5)]


def average_hsl_colour(image: Image.Image) -> list:
    average_hue_x = 0.0
    average_hue_y = 0.0
    average_sat = 0.0
    average_lightness = 0.0
    average_alpha = 0.0
    max_count = float(image.width * image.height)
    for x in range(image.width):
        for y in range(image.height):
            colour = image.getpixel((x, y))
            # Hue is cyclic, so gotta do
            # theta = [355,5,5,5,5];
            # x = cosd(theta); % cosine in terms of degrees
            # y = sind(theta); % sine with a degree argument
            # meanangle = atan2(mean(y),mean(x))*180/pi
            hsl = colorsys.rgb_to_hls(colour[0] / 255.0, colour[1] / 255.0, colour[2] / 255.0)
            # h is given from 0 to 1, to make it radians, it must be from 0 to 2pi
            average_hue_x += math.cos(hsl[0] * 2 * math.pi)
            average_hue_y += math.sin(hsl[0] * 2 * math.pi)
            average_sat += hsl[1] * 100
            average_lightness += hsl[2] * 100
            average_alpha += colour[3]

    average_hue = math.atan2(average_hue_y / max_count, average_hue_x / max_count) * 180 / math.pi
    average_sat /= max_count
    average_lightness /= max_count
    average_alpha /= max_count

    # Back to rgb
    rgb = colorsys.hls_to_rgb(average_hue / 360, average_sat / 100, average_lightness / 100)
    return [round(rgb[0] * 255), round(rgb[1] * 255), round(rgb[2] * 255), round(average_alpha)]


def average_hsv_colour(image: Image.Image) -> list:
    average_hue_x = 0.0
    average_hue_y = 0.0
    average_sat = 0.0
    average_value = 0.0
    average_alpha = 0.0
    max_count = float(image.width * image.height)
    for x in range(image.width):
        for y in range(image.height):
            colour = image.getpixel((x, y))
            # Hue is cyclic, so gotta do
            # theta = [355,5,5,5,5];
            # x = cosd(theta); % cosine in terms of degrees
            # y = sind(theta); % sine with a degree argument
            # meanangle = atan2(mean(y),mean(x))*180/pi
            hsv = colorsys.rgb_to_hsv(colour[0] / 255.0, colour[1] / 255.0, colour[2] / 255.0)
            # h is given from 0 to 1, to make it radians, it must be from 0 to 2pi
            average_hue_x += math.cos(hsv[0] * 2 * math.pi)
            average_hue_y += math.sin(hsv[0] * 2 * math.pi)
            average_sat += hsv[1] * 100
            average_value += hsv[2] * 100
            average_alpha += colour[3]

    average_hue = (math.atan2(average_hue_y / max_count, average_hue_x / max_count) * 180 / math.pi) % 360
    average_sat /= max_count
    average_value /= max_count
    average_alpha /= max_count

    # Back to rgb
    rgb = colorsys.hsv_to_rgb(average_hue / 360, average_sat / 100, average_value / 100)
    return [round(rgb[0] * 255), round(rgb[1] * 255), round(rgb[2] * 255), round(average_alpha)]


def average_lab_colour(image: Image.Image) -> list:
    rgb_image = image.convert("RGB")
    # Convert to Lab colourspace
    srgb_p = ImageCms.createProfile("sRGB")
    lab_p = ImageCms.createProfile("LAB")

    rgb2lab = ImageCms.buildTransformFromOpenProfiles(srgb_p, lab_p, "RGB", "LAB")
    Lab = ImageCms.applyTransform(rgb_image, rgb2lab)

    max_count = float(image.width * image.height)
    average_l = 0.0
    average_a = 0.0
    average_b = 0.0
    for x in range(image.width):
        for y in range(image.height):
            colour = Lab.getpixel((x, y))
            average_l += colour[0]
            average_a += colour[1]
            average_b += colour[2]

    average_l /= max_count
    average_a /= max_count
    average_b /= max_count

    temp_img = Image.new("LAB", size=(image.width, image.height))
    for x in range(image.width):
        for y in range(image.height):
            temp_img.putpixel((x, y), (round(average_l), round(average_a), round(average_b)))

    lab2rgb = ImageCms.buildTransformFromOpenProfiles(lab_p, srgb_p, "LAB", "RGB")
    back_rgb = ImageCms.applyTransform(temp_img, lab2rgb)
    col = back_rgb.getpixel((0, 0))

    # Get average average alpha
    average_alpha = 0.0
    for x in range(image.width):
        for y in range(image.height):
            pixel = image.getpixel((x, y))
            average_alpha += pixel[3] * pixel[3]

    average_alpha = average_alpha / max_count
    return [col[0], col[1], col[2], round(average_alpha ** 0.5)]


# https://stackoverflow.com/a/50900143
def dominant_colour(image: Image.Image) -> list:
    img_arr = np.asarray(image.convert('RGB'))
    a2D = img_arr.reshape(-1, img_arr.shape[-1])
    col_range = (256, 256, 256)  # generically : a2D.max(0)+1
    a1D = np.ravel_multi_index(a2D.T, col_range)
    rgb = list(np.unravel_index(np.bincount(a1D).argmax(), col_range))

    # Get average average alpha
    average_alpha = 0.0
    for x in range(image.width):
        for y in range(image.height):
            pixel = image.getpixel((x, y))
            average_alpha += pixel[3] * pixel[3]

    average_alpha = average_alpha / (image.width * image.height)

    return [int(rgb[0]), int(rgb[1]), int(rgb[2]), round(average_alpha ** 0.5)]

>>> src/logic/manage_audio_tab.py
import random
import src.ui_manager.PySimpleGUI as sg
# Extra variables
text_list = [
    'Oi', 'Oii', 'Stop it!',
    'Cant you read?', 'Just stop it already!',
    'OIIIIIII', 'Hellloooooo? Stop it!',
    'Ok this is the 3rd last warning',
    'Second Last Warning',
    'You know what, you dont get a last warning. Bye!'
]

extra_chars = list("~!@#$%^&*_+`:;<>,.?/")
all_chars = list("qwertyuiopasdfghjklzxcvbnm1234567890-=[]\\;',./~!@#$%^&*()_+{}:\"?><|")
text_iter = - 1
anger_level = 0
currently_angry = False
over_time = False
wait_time = 0
waiting_time = 120
goodbye = False
tab_close = False
rate_of_wait = 1


def manage_audio_tab(window, event, values):
    global text_iter, anger_level, wait_time, currently_angry, waiting_time, goodbye, over_time, tab_close, rate_of_wait
    if not goodbye:
        if event == "-Audio_Easter_Egg-" and waiting_time >= -100:

            text_iter += 1
            text_to_show = text_list[text_iter % len(text_list)] + "".join(
                [random.choice(extra_chars) for _ in range(anger_level)])
            # We shall shuffle!
            for i in range(anger_level):
                text_to_show = random_character_swapper(text_to_show)

            if text_iter % len(text_list) == (len(text_list) - 1):
                anger_level += 1
                currently_angry = True
                window['-Audio_Easter_Egg-'](disabled=True)
                window['-Audio_Easter_Egg-'](button_color="#404040")
                window['-Audio_Easter_Egg-'].Widget.configure(disabledforeground='#9e9e9e')
                wait_time = 0
            window['-Audio_Easter_Egg-'](text=text_to_show)

        if event == '__TIMEOUT__' and currently_angry:
            wait_time += 1
            if waiting_time < -100 and 405 > wait_time > 200:
                window['-Audio_Easter_Egg-'](text="You just cant stop")
            elif waiting_time < -100 and 625 > wait_time > 405:
                window['-Audio_Easter_Egg-'](text="I suppose i have to step in at some time")
            elif waiting_time < -100 and 805 > wait_time > 625:
                window['-Audio_Easter_Egg-'](text="Its over now.")
            elif waiting_time < -100 and 1065 > wait_time > 805:
                window['-Audio_Easter_Egg-'](text="Goodbye")
            elif waiting_time < -100 and 1200 > wait_time > 1065:
                window['-Audio_Easter_Egg-'](visible=False)
                goodbye = True
                wait_time = 0

            elif wait_time > waiting_time and not over_time:
                currently_angry = False
                waiting_time -= 10
                window['-Audio_Easter_Egg-'](disabled=False)
                window['-Audio_Easter_Egg-'](button_color=sg.DEFAULT_BUTTON_COLOR)

        if waiting_time < -100 and not over_time:
            window['-Audio_Easter_Egg-'](disabled=True)
            window['-Audio_Easter_Egg-'](text="Wow")
            currently_angry = True
            over_time = True
            wait_time = 0

    if goodbye and not tab_close:
        wait_time += rate_of_wait
        if wait_time < 5000:
            if wait_time % 10 == 0:
                for obj in window['-Audio_Frame-'].Rows:
                    if 'DisplayText' in dir(obj[0]):
                        display_text = obj[0].DisplayText
                        if wait_time % 30 == 0:
                            display_text += random.choice(all_chars)
                        new_display_text = random_character_swapper(display_text)
                        obj[0](value=new_display_text)
                tab_title = window['-Audio_Tab-'].Title
                if wait_time % 50 == 0:
                    tab_title += random.choice(all_chars)
                new_tab_title = random_character_swapper(tab_title)
                window['-Audio_Tab-'](title=new_tab_title)
            if wait_time % 200 == 0:
                rate_of_wait = 5 if rate_of_wait < 5 else rate_of_wait
            if wait_time % 400 == 0:
                rate_of_wait = 10 if rate_of_wait < 10 else rate_of_wait
            if wait_time % 800 == 0:
                rate_of_wait = 50
        else:
            rate_of_wait = 1
            if wait_time-5000 < 2:
                for obj in window['-Audio_Frame-'].Rows:
                    if 'DisplayText' in dir(obj[0]):
                        obj[0](value="Bye")
                window['-Audio_Tab-'](title="https://www.mediafire.com/file/aphpwatldywxey8/youfoundit.wav/")
            if wait_time-5000 == 100:
                window['-Audio_Tab-'](visible=False)
                tab_close = True


def random_character_swapper(text: str) -> str:
    pos1 = random.randrange(0, len(text))
    pos2 = random.randrange(0, len(text))
    while pos2 == pos1:
        pos2 = random.randrange(0, len(text))
    list_text_to_shot = list(text)
    if pos1 > pos2:
        pos1, pos2 = pos2, pos1
    list_text_to_shot.insert(pos1, list_text_to_shot.pop(pos2))
    list_text_to_shot.insert(pos2, list_text_to_shot.pop(pos1 + 1))
    return "".join(list_text_to_shot)

>>> src/logic/manage_events.py
import src.ui_manager.PySimpleGUI as sg

from src.logic.manage_image_tab import manage_img_tab
from src.logic.manage_video_tab import manage_vid_tab
from src.logic.manage_audio_tab import manage_audio_tab
from src.logic.popup_manager import manage_popups


def manage_events(window: sg.Window):
    # Display and interact with the Window using an Event Loop
    while True:
        event, values = window.read(timeout=20)
        # See if user wants to quit or window was closed
        if event in [sg.WINDOW_CLOSED, 'QUIT!']:
            break

        if "Popup" in event:
            manage_popups(event)
        # Manage image events
        manage_img_tab(window, event, values)
        # Manage video events
        manage_vid_tab(window, event, values)
        # Manage audio events
        manage_audio_tab(window, event, values)


>>> src/logic/manage_image_tab.py
import os
import time

import src.ui_manager.PySimpleGUI as sg
from src.logic.fileio.file_verifier import check_file_exists
from src.logic.fileio.image_thumbnail import load_image_for_display, load_image_for_preview
from src.logic.image_logic.image_manager import manipulate_image
from io import BytesIO
import logging
logger = logging.getLogger(__name__)

img_info = {"path": "", "bytes": BytesIO(), "size": [0, 0], "img_size": [0, 0]}


def manage_img_tab(window, event, values):
    # Loads a preview of the selected image
    if event == "-Submit_ITS-":
        img_info['path'] = values['-Text Entered-']
        img_info['img_size'], img_info['bytes'] = load_image_for_display(
            values['-Text Entered-'],
            sg.Window.get_screen_size()
        )
        if img_info['bytes'] is None:
            sg.popup("ERROR!", "Error in file path!")
            return
        elif not img_info['bytes']:
            sg.popup("ERROR!", "Some error in opening/reading the file! Are you sure its an image?")
            return
        window['-LOADED_IMAGE-'](data=img_info['bytes'].getvalue())
        window['-LOADED_IMAGE-'](visible=True)
        window['-Img_Attrs-'](visible=True)
        preview_bytes = load_image_for_preview(
            img_info['bytes'],
            {
                'manipulation': values["-Img_Type-"],
                'brightness': 127,
                'blocklist': values['-Img_Any_Listing_List-'],
                'mode': values['-Img_Any_Options-'],
                'side': values['-Img_Any_Side-'].lower(),
                'dither': values['-Img_Dithering-'],
                'alternate': values['-Img_Lamps_Alternate-'],
                'color_set': values['-Color_Set-'],
                'color_compare': values['-Comparison_Method-']
            }
        )
        window['-Preview_Image-'](data=preview_bytes.getvalue())

        # Updates the text which tells the final resolution of the output
        scale = values['-Img_Scale-']
        scale = int(scale[:-1])

        crop_topx = values['-Img_Crop_Top_X-']
        crop_topy = values['-Img_Crop_Top_Y-']
        crop_bottom_x = values['-Img_Crop_Bottom_X-']
        crop_bottom_y = values['-Img_Crop_Bottom_Y-']

        crop_topx = 0 if crop_topx.lower() == "" else crop_topx
        crop_topy = 0 if crop_topy.lower() == "" else crop_topy
        crop_bottom_x = img_info['img_size'][0] if crop_bottom_x.lower() in ["max", ""] else crop_bottom_x
        crop_bottom_y = img_info['img_size'][1] if crop_bottom_y.lower() in ["max", ""] else crop_bottom_y

        if any([not str(i).isdigit() for i in [crop_topx, crop_topy, crop_bottom_x, crop_bottom_y]]):
            sg.popup("ERROR!", "Invalid Crop Values!")
            return

        # These are the cropped sizes
        new_size_width = crop_bottom_x - crop_topx
        new_size_height = crop_bottom_y - crop_topy
        new_scale = 1 / scale * 16
        if new_size_width % new_scale != 0:
            new_width = new_size_width + (new_scale - (new_size_width % new_scale))
        else:
            new_width = new_size_width

        if new_size_height % new_scale != 0:
            new_height = new_size_height + (new_scale - (new_size_height % new_scale))
        else:
            new_height = new_size_height

        # These are the final images sizes with the current configurations
        img_info['size'][0], img_info['size'][1] = new_width, new_height

        # Update the text
        update_size(window, scale, values)

    # Enabled the button if the entered path is valid
    if event == "-Text Entered-":
        if check_file_exists(values['-Text Entered-']):
            window['-Submit_ITS-'](disabled=False)
        else:
            window['-Submit_ITS-'](disabled=True)

    # Update the output resolution text if the scale changes
    if event == "-Img_Scale-":
        scale = values['-Img_Scale-']
        scale = int(scale[:-1])
        update_size(window, scale, values)

    # Enabling or disabling the view to certain elements, if they are not associated with the selected mode(-Img_Type-)
    if event == "-Img_Type-":
        if "Any" in values['-Img_Type-']:
            window['-Redstone_Lamps_Key-'](visible=False)
            window['-Any_Block_Key-'](visible=True)
            window.refresh()
            window['-Img_Attrs-'].contents_changed()
        else:
            window['-Any_Block_Key-'](visible=False)
            window['-Redstone_Lamps_Key-'](visible=True)
            window.refresh()
            window['-Img_Attrs-'].contents_changed()

        if values['-Img_Type-'] == "Image To Redstone Lamps Schematic":
            window['-Img_Lamps_Schem_Check-'](visible=True)
        else:
            window['-Img_Lamps_Schem_Check-'](visible=False)

        if "Schematic" in values['-Img_Type-']:
            window['-Img_Save_As_Img-'](visible=False)
            window['-Img_Save_As_Schem-'](visible=True)
        else:
            window['-Img_Save_As_Schem-'](visible=False)
            window['-Img_Save_As_Img-'](visible=True)

        # Updating the Text
        scale = values['-Img_Scale-']
        scale = int(scale[:-1])
        update_size(window, scale, values)

    # Updating the final resolution text if any cropping is made
    if "Img_Crop" in event:
        scale = values['-Img_Scale-']
        scale = int(scale[:-1])

        crop_topx = values['-Img_Crop_Top_X-']
        crop_topy = values['-Img_Crop_Top_Y-']
        crop_bottom_x = values['-Img_Crop_Bottom_X-']
        crop_bottom_y = values['-Img_Crop_Bottom_Y-']

        crop_topx = 0 if crop_topx.lower() == "" else crop_topx
        crop_topy = 0 if crop_topy.lower() == "" else crop_topy
        crop_bottom_x = img_info['img_size'][0] if crop_bottom_x.lower() in ["max", ""] else crop_bottom_x
        crop_bottom_y = img_info['img_size'][1] if crop_bottom_y.lower() in ["max", ""] else crop_bottom_y

        if any([not str(i).isdigit() for i in [crop_topx, crop_topy, crop_bottom_x, crop_bottom_y]]):
            sg.popup("ERROR!", "Invalid Crop Values!")
            return

        crop_topx = int(crop_topx)
        crop_topy = int(crop_topy)
        crop_bottom_x = int(crop_bottom_x)
        crop_bottom_y = int(crop_bottom_y)

        new_size_width = crop_bottom_x - crop_topx
        new_size_height = crop_bottom_y - crop_topy
        new_scale = 1 / scale * 16
        if new_size_width % new_scale != 0:
            new_width = new_size_width + (new_scale - (new_size_width % new_scale))
        else:
            new_width = new_size_width

        if new_size_height % new_scale != 0:
            new_height = new_size_height + (new_scale - (new_size_height % new_scale))
        else:
            new_height = new_size_height

        img_info['size'][0], img_info['size'][1] = new_width, new_height
        update_size(window, scale, values)

    # What to do when clicking the run button
    if event == "-Img_Run-":
        # Manage the crop
        crop_topx = values['-Img_Crop_Top_X-']
        crop_topy = values['-Img_Crop_Top_Y-']
        crop_bottom_x = values['-Img_Crop_Bottom_X-']
        crop_bottom_y = values['-Img_Crop_Bottom_Y-']
        all_crop = [crop_topx, crop_topy, crop_bottom_x, crop_bottom_y]
        if all_crop[0] == "":
            all_crop[0] = "0"
        if all_crop[1] == "":
            all_crop[1] = "0"
        if all_crop[2] == "":
            all_crop[2] = "Max"
        if all_crop[3] == "":
            all_crop[3] = "Max"

        if not all((all_crop[i].isdigit() or (all_crop[i].lower() == "max" and i in [2, 3])) for i in range(4)):
            sg.popup("Error!", "Invalid values in crop! Only integers accepted!(Or max for the bottom coordinates)")
            return

        img_type = values['-Img_Type-']
        details = {
            'blocklist': values['-Img_Any_Listing_List-'],
            'mode': values['-Img_Any_Options-'],
            'dither': values['-Img_Dithering-'],
            'alternate': values['-Img_Lamps_Alternate-'],
            'color_set': values['-Color_Set-'],
            'color_compare': values['-Comparison_Method-']
        }

        scale = values['-Img_Scale-']

        details['side'] = values['-Img_Any_Side-'].lower()
        # Setting the correct output path if unspecified
        if values['-Output_Path-'] == "":
            if "Schematic" in img_type:
                file_end = ".schem"
            else:
                file_end = ".png"
            if not os.path.exists("./mcIVASMAKER_output"):
                os.makedirs("./mcIVASMAKER_output")
            output = f"./mcIVASMAKER_output/output{time.strftime('%y_%m_%d-%H_%M_%S', time.localtime())}{file_end}"
        else:
            output = values['-Output_Path-']

        details['brightness'] = values['-Image_Brightness-']
        details['place_redstone_blocks'] = values['-Img_Lamps_Schem_Check-']

        logger.info("Image Conversion")
        logger.debug("Video Details:")
        logger.debug("FilePath: " + img_info['path'])
        logger.debug("Output Path: " + output)
        logger.debug("Manupilations: " + img_type)
        logger.debug(f"Crop: {all_crop}")
        logger.debug(f"Scale: {scale}")
        logger.debug(f"Details: {details}")

        iteration = 0
        progress_size = 0
        # manipulate_image is a generator, so we can update the progress more easily
        for progress in manipulate_image(
                filepath=img_info['path'],
                output=output,
                manipulation=img_type,
                crop=all_crop,
                scale=scale,
                details=details
        ):
            if iteration == 0:
                progress_size = progress - 1
                iteration += 1
                continue
            if progress == "Done Processing!":
                sg.one_line_progress_meter(
                    "Saving..", 0, 1, "Saving...", no_button=True, orientation='horizontal', no_titlebar=True
                )
                continue
            if progress == "Done!":
                sg.one_line_progress_meter(
                    "Saving..", 1, 1, no_button=True, no_titlebar=True, orientation='horizontal',
                )
                sg.popup_auto_close("Done!", "Done!", auto_close_duration=4)
                logger.info("Done Image!")
                continue
            iteration += 1
            sg.one_line_progress_meter(
                "Working...", progress, progress_size, no_button=True, orientation='horizontal'
            )

    # Deselecting the ListBox
    if event == "Deselect All":
        window['-Img_Any_Listing_List-'](set_to_index=[])

    # Updating the preview image if any options change
    if event in [
        "-Image_Brightness-",
        "-Img_Any_Side-",
        "-Img_Any_Options-",
        "-Img_Type-",
        "-Img_Any_Listing_List-",
        "-Img_Lamps_Alternate-",
        "-Img_Dithering-",
        "-Color_Set-",
        "-Comparison_Method-"
    ] and values['-Update_Preview-']:
        preview_bytes = load_image_for_preview(
            img_info['bytes'],
            {
                'manipulation': values["-Img_Type-"],
                'brightness': values['-Image_Brightness-'],
                'blocklist': values['-Img_Any_Listing_List-'],
                'mode': values['-Img_Any_Options-'],
                'side': values['-Img_Any_Side-'].lower(),
                'dither': values['-Img_Dithering-'],
                'alternate': values['-Img_Lamps_Alternate-'],
                'color_set': values['-Color_Set-'],
                'color_compare': values['-Comparison_Method-']
            }
        )
        window['-Preview_Image-'](data=preview_bytes.getvalue())


# Resolution text updater
def update_size(window: sg.Window, scale: int, values):
    if "Schematic" in values['-Img_Type-']:
        total_size = (img_info['size'][0] * scale / 16, img_info['size'][1] * scale / 16)
        window['-Img_Scale_Warning-'](f"Size: ({total_size[0]},{total_size[1]}) blocks")
    else:
        total_size = (img_info['size'][0] * scale, img_info['size'][1] * scale)
        window['-Img_Scale_Warning-'](f"Size: ({total_size[0]},{total_size[1]}) pixels\n"
                                      f"Each block is 16x16 pixels")

>>> src/logic/manage_video_tab.py
import os
import time
from io import BytesIO

from PIL import Image

import src.ui_manager.PySimpleGUI as sg
from src.logic.fileio.file_verifier import check_file_exists
from src.logic.vid_logic.ffmpeg_manager import get_resolution, get_frame_count
from src.logic.vid_logic.vid_manager import vid_manager
from src.path_manager.pather import resource_path

# Loads up the progress animation
IMAGES = []
frame_count = 0
for i in range(60):
    img = Image.open(resource_path(f"./assets/gifs/vid_progress/{i}.png"))
    img = img.resize((50, 50))
    with BytesIO() as out:
        img.save(out, format="PNG")
        data = out.getvalue()
    img.close()
    IMAGES.append(data)

vid_info = {"path": ""}

images_done = 0
img_count = 0
process_running = False
THREAD_KEY = '-Vid_Thread-'

image_size = (0, 0)
advance_state = False


def manage_vid_tab(window, event, values):
    global images_done, img_count
    global process_running
    global THREAD_KEY
    global image_size
    global advance_state

    # Only updating the options, if there is no video conversion going on
    if not process_running:
        # Loads up video attributes
        if event == "-Submit_VTS-":
            vid_info['path'] = values['-Vid Text Entered-']
            window['-Vid_Attrs-'](visible=True)
            window['-Vid_Loaded-'](f"Loaded Video: {vid_info['path']}")
            image_size = get_resolution(vid_info['path'])
            inp_scale = values['-Vid_Scale-']
            scale = int(inp_scale[:-1])
            # If the final resolution is too big, ffmpeg does not work
            # Also large resolutions might even crash the computer
            if image_size[0] * scale > 8000 or image_size[1] * scale > 8000:
                if image_size[0] * scale > 32767 or image_size[1] * scale > 32767:
                    window['-Vid_Scale_Warning-'](
                        "ERROR: ffmpeg only allows the max size of the video to be 32767x32767\n"
                        f"Detected size : ({image_size[0] * scale},{image_size[1] * scale}), Use a smaller scale",
                        text_color="#FF1111"
                    )
                    window['-Vid_Run-'](disabled=True)
                else:
                    window['-Vid_Scale_Warning-'](
                        f"Warning: The resolution is gigantic({image_size[0] * scale},{image_size[1] * scale}).\n"
                        "This may take a long time to run\n"
                        "There is a high chance of the program hanging\n"
                        "and your entire system crashing\n"
                        "Proceed with Caution",
                        text_color="#FFFF0F"
                    )
            else:
                window['-Vid_Scale_Warning-'](
                    f"Output Resolution: ({image_size[0] * scale},{image_size[1] * scale})",
                    text_color="#FFFFFF"
                )
            window['-Frame_Count-'](f"Frame Count: {get_frame_count(vid_info['path'], values['-Vid_Frame_Rate-'])}")

        if event == '-Vid_Scale-':
            inp_scale = values['-Vid_Scale-']
            scale = int(inp_scale[:-1])
            if image_size[0] * scale > 8000 or image_size[1] * scale > 8000:
                if image_size[0] * scale > 32767 or image_size[1] * scale > 32767:
                    window['-Vid_Scale_Warning-'](
                        "ERROR: ffmpeg only allows the max size of the video to be 32767x32767\n"
                        f"Detected size : ({image_size[0] * scale},{image_size[1] * scale}), Use a smaller scale",
                        text_color="#FF1111"
                    )
                    window['-Vid_Run-'](disabled=True)
                else:
                    window['-Vid_Scale_Warning-'](
                        f"Warning: The resolution is gigantic({image_size[0] * scale},{image_size[1] * scale}).\n"
                        f"This may take a long time to run\n"
                        "There is also a chance of it silently failing,\n"
                        "and your entire system crashing\n"
                        "Proceed with Caution",
                        text_color="#FFFF0F"
                    )
                    window['-Vid_Run-'](disabled=False)
            else:
                window['-Vid_Run-'](disabled=False)
                window['-Vid_Scale_Warning-'](
                    f"Output Resolution: ({image_size[0] * scale},{image_size[1] * scale})",
                    text_color="#FFFFFF"
                )

        # Enabled the load button if the path is valid
        if event == "-Vid Text Entered-":
            if check_file_exists(values['-Vid Text Entered-']):
                window['-Submit_VTS-'](disabled=False)
            else:
                window['-Submit_VTS-'](disabled=True)

        # Updating the frame count text if the frame rate slider is moved
        if event == "-Vid_Frame_Rate-":
            window['-Frame_Count-'](f"Frame Count: {get_frame_count(vid_info['path'], values['-Vid_Frame_Rate-'])}")

        # Show certain elements, depending on which modes are enabled
        if event == "-Vid_Type-":
            if "Any" in values['-Vid_Type-']:
                window['-Vid_Redstone_Lamps_Key-'](visible=False)
                window['-Vid_Any_Block_Key-'](visible=True)
                window.refresh()
                window['-Vid_Attrs-'].contents_changed()
            else:
                window['-Vid_Any_Block_Key-'](visible=False)
                window['-Vid_Redstone_Lamps_Key-'](visible=True)
                window.refresh()
                window['-Vid_Attrs-'].contents_changed()

        # Showing/hiding advance options, on clicking the advance options text
        if event == "-Advance_Dropdown-":
            if advance_state:
                window['-Advance_Dropdown-']("Advance Options ∧")
                window['-Advance_Options-'](visible=False)
            else:
                window['-Advance_Dropdown-']("Advance Options v")
                window['-Advance_Options-'](visible=True)
            advance_state = not advance_state

        # Deselecting the ListBox
        if event == "Deselect All":
            window['-Vid_Any_Listing_List-'](set_to_index=[])

        # On clicking the run button
        if event == "-Vid_Run-":
            frame_rate = values["-Vid_Frame_Rate-"]
            details = {
                'blocklist': values['-Vid_Any_Listing_List-'],
                'mode': values['-Vid_Any_Options-'],
                'quality': values['-Vid_Quality-'],
                'frame_rate': frame_rate,
                'dither': values['-Vid_Dithering-'],
                'alternate': values['-Vid_Lamps_Alternate-'],
                'color_set': values['-Vid_Color_Set-'],
                'color_compare': values['-Vid_Comparison_Method-']
            }

            # Validating the process count
            process_count = values['-Process_Count-']
            if not str(process_count).isdigit():
                process_count = 2
            elif not (1 <= int(process_count) <= 16):
                process_count = 2
            else:
                process_count = int(process_count)

            details['process_count'] = process_count

            scale = values['-Vid_Scale-']
            vid_type = values['-Vid_Type-']
            details['side'] = values['-Vid_Any_Side-'].lower()
            filepath = vid_info['path']
            # Setting the correct output location
            if values['-Vid_Output_Path-'] == "":
                if not os.path.exists("./mcIVASMAKER_output"):
                    os.makedirs("./mcIVASMAKER_output")
                output = f"./mcIVASMAKER_output/output{time.strftime('%y_%m_%d-%H_%M_%S', time.localtime())}.mp4"
            else:
                output = values['-Vid_Output_Path-']

            details['brightness'] = values['-Vid_Brightness-']
            process_running = True

            window['-Vid_Run-'](disabled=True)
            window['-Vid_Progress_Meters-'](visible=True)

            # This runs the function in another thread, so the gui can be kept updated
            window.perform_long_operation(lambda: vid_manager(
                window=window,
                filepath=filepath,
                output=output,
                manipulation=vid_type,
                scale=scale,
                details=details
            ), '-Vid Process Complete-')

    # When the thread is running
    if event[0] == THREAD_KEY:
        # Update the progress meter
        if event[1] == '-Image_Count-':
            img_count = values[event]
        if event[1] == '-Reset_Images_Done-':
            images_done = 0
        if event[1] == "-Set_Images_Done-":
            images_done = values[event]
        if event[1] == "-Image_Done-":
            images_done += 1
            progress = images_done / img_count * 100
            window['-Number_Of_Frames-'](progress)
            window['-Number_Of_Frames_Text-'](f"{images_done}/{img_count}")

        if event[1] == '-Img_Conversion-':
            window['-Images_Vid_Conversion-'](values[event])

    # If the processing is complete, allow the options to work again, and reset the progress meters
    if event == "-Vid Process Complete-":
        sg.popup("Done!", auto_close=True, auto_close_duration=10)
        process_running = False
        images_done = 0
        img_count = 0
        window['-Vid_Run-'](disabled=False)
        window['-Number_Of_Frames-'](0)
        window['-Images_Vid_Conversion-'](0)
        window['-Single_Frame-'](0)

    # Updating the progress animations, every certain amount of time
    if event == sg.TIMEOUT_KEY and process_running:
        update_animation(window)


# This updates the progress animation
def update_animation(window):
    global IMAGES
    global frame_count

    image = IMAGES[frame_count % 60]

    frame_count += 1
    window['-Progress_Gif-'](data=image)
    pass

>>> src/logic/popup_manager.py
import src.ui_manager.PySimpleGUI as sg


def manage_popups(event):
    if event in ["-Average_Colour_Popup-", "-Vid_Average_Colour_Popup-"]:
        sg.popup_scrolled(
            """
            Average Color These are the pre-computed color averages of each minecraft block, in different ways \n
            -   Linear Average\n
                    The original average color list. It uses the arithmetic mean of all pixels of a minecraft block\n\n
            -   Root Mean Square Average\n
                    It is said in a legend once forgotten,
                    that rgb should be squared before taking the arithmetic mean
                    as whats shown to the world had been previously rooted\n\n
            -   HSL / HSV average\n
                    Converted rgb to hsl, before taking that average, Might be better idk\n\n
            -   Lab Average\n
                    'L*a*b*', referred to as lab, is the holy grail of color spaces or something, as it is supposed to based on human perception\n\n
            -   Dominant color\n
                    The most dominant color in the block is used here\n\n
            
            Note, i dont think there is any 'better' choice here\n
            You should choose whichever look the best/has best outcome for what you want
            """,
            background_color="#2a2b2c",
            title="Average Colour In Detailed",
            text_color="#FFFFFF",
            size=(130, 30)
        )

    if event in ["-Color_Difference_Popup-", "-Vid_Color_Difference_Popup-"]:
        sg.popup_scrolled(
            """
            This setting changes how the color values of each pixel is compared to the averaged minecraft block\n
            -   Absolute Difference\n
                    Adds up the absolute differences between the rgb values. This is theoretically the fastest\n\n
            -   Euclidean Difference\n
                    Very similar to absolute differences, but adds up the square of the differences between the rgb values\n\n
            -   Weighted Euclidean\n
                    Same as euclidean difference, but red, green and blue are weighted somewhat to match our eye's perception\n\n
            -   Redmean Difference\n
                    Similar to weighted euclidean, but is smoother in its working\n\n
            -   CIE76 DelE\n
                    Theoretically matches the color difference like our eyes the most, as compared to others
                    as it is based on a more human perception related color space
                    It is also much slower than the others\n\n

            Note, i dont think there is any 'better' choice here either\n
            You should choose whichever look the best/has best outcome for what you want
            """,
            background_color="#2a2b2c",
            title="Color Difference",
            text_color="#FFFFFF",
            size=(130, 30)
        )

>>> src/logic/fileio/image_thumbnail.py
import src.logic.fileio.file_verifier as image_handler
from src.logic.image_logic import image_to_redstone_lamps, img_to_blocks
import PIL
from PIL import Image
import io
import math
from typing import TypedDict


class DetailsType(TypedDict):
    manipulation: str
    brightness: int
    dither: bool
    alternate: bool
    blocklist: list[str]
    mode: str
    side: str
    color_set: str
    color_compare: str


# Loads the image for displaying in the preview
def load_image_for_display(filepath: str, size: tuple[int, int]) -> bool | tuple[list[int], io.BytesIO] | None:
    if image_handler.check_file_exists(filepath):
        try:
            img = Image.open(filepath)
        except (FileNotFoundError, PIL.UnidentifiedImageError):
            return False

        width = img.width
        height = img.height
        img_size = [432, 240]

        img_size[0] = min(432, math.floor(size[0] / 2))
        img_size[1] = min(240, math.floor(size[1] / 2))

        img.thumbnail((img_size[0], img_size[1]), Image.Resampling.LANCZOS)
        b_io = io.BytesIO()
        img.save(b_io, format="PNG")
        return [width, height], b_io
    return None
    pass


# Converts the loaded image, to put it to preview
def load_image_for_preview(
        image_bytes: io.BytesIO,
        details: DetailsType
):
    img = Image.open(image_bytes)
    img.thumbnail((img.width // 2, img.height // 2))
    out_img = None
    if "Lamps" in details['manipulation']:
        for value in image_to_redstone_lamps.img_to_redstone_lamps(
                img, details['brightness'], details['dither'], details['alternate']
        ):
            if isinstance(value, Image.Image):
                out_img = value
        out_img.thumbnail((350, 240))
        # Saving the image in a bytes format, so it can be used without storing as a file
        b_io = io.BytesIO()
        out_img.save(b_io, format="PNG")
        return b_io
    elif "Any" in details['manipulation']:
        img = img.convert("RGBA")
        img.thumbnail((img.width // 2, img.height // 2))
        for value in img_to_blocks.img_to_blocks(
                img, {
                    'side': details['side'],
                    'blocked_list': details['blocklist'],
                    'mode': details['mode'],
                    'color_set': details['color_set'][0],
                    'color_compare': details['color_compare'][0]
                }
        ):
            if isinstance(value, Image.Image):
                out_img = value
        out_img.thumbnail((350, 240))
        b_io = io.BytesIO()
        out_img.save(b_io, format="PNG")
        return b_io
    return image_bytes

>>> src/logic/fileio/file_verifier.py
import os.path


# Checks if a file exists
def check_file_exists(filepath: str) -> bool:
    return os.path.isfile(filepath)


def check_if_file_image(filepath: str) -> bool:
    list_of_image_extensions = (
        ".png",
        ".jpg",
        ".jpeg",
    )
    if filepath.endswith(list_of_image_extensions):
        return True
    return False

>>> src/logic/image_logic/block_parser.py

def block_parser(block: str) -> str:
    if block == "bee_nest_honey":
        output = "bee_nest[honey_level=5]"
    elif block == "beehive_honey":
        output = "beehive[honey_level=5]"
    elif block == "blast_furnace_on":
        output = "blast_furnace[lit=true]"
    elif block == "chorus_flower_dead":
        output = "chorus_flower[age=5]"
    elif block == "daylight_detector_inverted":
        output = "daylight_detector[inverted=true]"
    elif block == "dispenser":
        output = "dispenser[facing=up]"
    elif block == "dropper_vertical":
        output = "dropper[facing=up]"
    elif block == "farmland":
        output = "farmland"
    elif block == "farmland_moist":
        output = "farmland[moisture=7]"
    elif block == "furnace_on":
        output = "furnace[lit=true]"
    elif block == "jigsaw_lock":
        output = "jigsaw[orientation=up_north]"
    elif block == "lava_still":
        output = "lava"
    elif block == "mushroom_block_inside":
        output = "mushroom_stem[up=false,down=false,east=false,west=false,north=false,south=false]"
    elif block == "piston_sticky":
        output = "sticky_piston"
    elif block == "redstone_lamp_on":
        output = "redstone_lamp[lit=true]"
    elif block == "respawn_anchor_lit":
        output = "respawn_anchor[charges=4]"
    elif block == "sculk_shrieker_enabled":
        output = "sculk_shrieker[can_summon=true]"
    elif block == "smoker_on":
        output = "smoker[lit=true]"
    elif block == "structure_block_load":
        output = "structure_block"
    elif block == "structure_block_data":
        output = "structure_block[mode=data]"
    elif block == "structure_block_corner":
        output = "structure_block[mode=corner]"
    elif block == "structure_block_load":
        output = "structure_block[mode=load]"
    elif block == "structure_block_save":
        output = "structure_block[mode=save]"
    elif block == "magma":
        output = "magma_block"
    elif block == "dried_kelp":
        output = "dried_kelp_block"
    else:
        output = block

    output = "minecraft:" + output
    return output

>>> src/logic/image_logic/image_manager.py
import math
import os
import mcschematic
import logging
from typing import Union

from PIL import Image, ImageFile

# 现有逻辑复用的两个模块
from src.logic.image_logic import image_to_redstone_lamps, img_to_blocks as img_to_block_img
from src.logic.image_logic.block_parser import block_parser

logger = logging.getLogger(__name__)
ImageFile.LOAD_TRUNCATED_IMAGES = True

# 可选：Bedrock 结构导出（pip install mcstructure）
try:
    from mcstructure import Block, Structure
except Exception:
    Block = None
    Structure = None


def _normalize_scale_to_tile(step: Union[str, float, int]) -> int:
    """
    将用户传入的 scale 统一换算为算法需要的“瓦片步长”（用于 //scale 缩小），确保是 >=1 的整数。
    规则：
      - 如果是百分比字符串（如 "50%"、"12.5%"），先转成倍数（0.5、0.125），再计算。
      - 如果是数字（0.5、1、2.0），直接作为倍数。
      - 计算公式：tile = round(16 / 倍数)，并保证最小为 1。
        例：1.0 → 16；0.5 → 32；2.0 → 8
    """
    # 解析成倍数
    if isinstance(step, str):
        s = step.strip().lower()
        s = s.replace('×', 'x').replace('*', 'x').replace('x', '').strip()
        if s.endswith('%'):
            mult = float(s[:-1]) / 100.0
        else:
            mult = float(s)
    elif isinstance(step, (int, float)):
        mult = float(step)
    else:
        raise ValueError(f"Invalid scale type: {type(step)}")

    if mult <= 0:
        raise ValueError(f"scale must be > 0, got {mult}")

    tile = round(16.0 / mult)
    if tile < 1:
        tile = 1
    return tile


# Convert an image, to what the user specified
def manipulate_image(
        filepath: str, output: str, manipulation: str, crop: list | None, scale: Union[str, float, int], details: dict
):
    img = Image.open(filepath)
    # Validating the cropping
    if crop is not None:
        for i in range(4):
            if len(str(crop[i])) > 8:
                return False

            if crop[i] == "Max":
                crop[i] = img.width if i == 2 else img.height
            else:
                crop[i] = int(crop[i])

        if not all(1000000 > crop[i] >= 0 for i in range(4)):
            return False
        # Cropping the image
        img = img.crop((crop[0], crop[1], crop[2], crop[3]))

    # Scale to numeric tile step (integer >= 1)
    scale: int = _normalize_scale_to_tile(scale)

    # Getting the img to a multiple of 16 so textures match up
    if img.width % scale != 0:
        new_width = img.width + (scale - (img.width % scale))
    else:
        new_width = img.width

    if img.height % scale != 0:
        new_height = img.height + (scale - (img.height % scale))
    else:
        new_height = img.height

    img = img.crop((0, 0, new_width, new_height))
    img.thumbnail((img.width // scale, img.height // scale))
    yield img.width

    if manipulation == "Image To Any Block Image":
        img = img.convert("RGBA")
        for value in img_to_blocks(img, output, details):
            yield value
        return

    elif manipulation == "Image To Any Block Schematic":
        img = img.convert("RGBA")
        for value in img_to_blocks_schem(img, output, details):
            yield value
        return

    elif manipulation == "Image To Redstone Lamps Image":
        img = img.convert("RGB")
        for value in img_to_lamps(img, output, details):
            yield value
        return

    elif manipulation == "Image To Redstone Lamps Schematic":
        img = img.convert("RGB")
        for value in img_to_lamps_schem(img, output, details):
            yield value
        return

    # ==== 直接导出为 Bedrock 的 .mcstructure（基岩坐标原生写入） ====
    elif manipulation in ("image-mcs", "Image To Any Block MCStructure"):
        img = img.convert("RGBA")
        for value in img_to_blocks_mcs(img, output, details):
            yield value
        return

    # 兜底
    return


def img_to_lamps(img: Image.Image, output: str, details: dict):
    brightness = details['brightness']
    dither = details['dither']
    alternate = details['alternate']
    for value in image_to_redstone_lamps.img_to_redstone_lamps(img, brightness, dither, alternate):
        if isinstance(value, Image.Image):
            img = value
        else:
            yield value
    yield "Done Processing!"
    img.save(output)
    img.close()
    yield "Done!"
    return


def img_to_lamps_schem(img: Image.Image, output: str, details: dict):
    brightness = details['brightness']
    dither = details['dither']
    alternate = details['alternate']
    place_redstone_blocks = details['place_redstone_blocks']

    schem: mcschematic.MCSchematic = ...
    for value in image_to_redstone_lamps.img_to_redstone_lamps_schem(
            img, brightness, place_redstone_blocks, dither, alternate
    ):
        if isinstance(value, mcschematic.MCSchematic):
            schem: mcschematic.MCSchematic = value
        else:
            yield value
    yield "Done Processing!"
    head, tail = os.path.split(output)
    tail = tail.split(".")[0]
    schem.save(head, tail, mcschematic.Version.JE_1_20_1)
    yield "Done!"
    return


def img_to_blocks(img: Image.Image, output: str, details: dict):
    for value in img_to_block_img.img_to_blocks(
            img,
            {
                'side': details['side'],
                'blocked_list': details['blocklist'],
                'mode': details['mode'],
                'color_set': details['color_set'][0],
                'color_compare': details['color_compare'][0]
            }
    ):
        if isinstance(value, Image.Image):
            img = value
        else:
            yield value
    yield "Done Processing!"
    # --- JPEG 容错：退化为 RGB ---
    ext = os.path.splitext(output)[1].lower()
    if ext in ('.jpg', '.jpeg') and img.mode == 'RGBA':
        img = img.convert('RGB')
    img.save(output)
    img.close()
    yield "Done!"
    return


def img_to_blocks_schem(img: Image.Image, output: str, details: dict):
    schem: mcschematic.MCSchematic = ...
    for value in img_to_block_img.img_to_blocks_schem(
            img,
            {
                'side': details['side'],
                'blocked_list': details['blocklist'],
                'mode': details['mode'],
                'color_set': details['color_set'][0],
                'color_compare': details['color_compare'][0]
            }
    ):
        if isinstance(value, mcschematic.MCSchematic):
            schem: mcschematic.MCSchematic = value
        else:
            yield value
    yield "Done Processing!"
    head, tail = os.path.split(output)
    tail = tail.split(".")[0]
    schem.save(head, tail, mcschematic.Version.JE_1_20_1)
    yield "Done!"
    return


# ================= 新增：导出为 .mcstructure（基岩坐标原生） =================
def _parse_block_for_mcs(block_val) -> tuple[str, dict]:
    """
    兼容 block_parser(...) 的返回：
    - 若是字符串，支持 "minecraft:stone[axis=y,lit=true]" 简易解析
    - 若是字典，期望 {"name":"minecraft:stone", "states":{...}}
    返回: (full_name, states_dict)
    """
    def _norm(name: str) -> str:
        if not isinstance(name, str) or not name:
            return "minecraft:air"
        return name if name.startswith("minecraft:") else f"minecraft:{name}"

    # dict 形式
    if isinstance(block_val, dict):
        name = _norm(block_val.get("name", "minecraft:air"))
        states = block_val.get("states", {}) or {}
        if not isinstance(states, dict):
            states = {}
        return name, states

    # 字符串形式（可能带 [key=val,...]）
    if isinstance(block_val, str):
        s = block_val.strip()
        if "[" in s and s.endswith("]"):
            name, raw = s.split("[", 1)
            name = _norm(name.strip())
            raw = raw[:-1]  # 去掉尾部 ']'
            states = {}
            if raw:
                for pair in raw.split(","):
                    if "=" not in pair:
                        continue
                    k, v = pair.split("=", 1)
                    k = k.strip()
                    v = v.strip()
                    # 转成合适的类型
                    if v.lower() in ("true", "false"):
                        v = (v.lower() == "true")
                    else:
                        try:
                            if "." in v:
                                v = float(v)
                            else:
                                v = int(v)
                        except Exception:
                            pass
                    states[k] = v
            return name, states
        else:
            return _norm(s), {}

    # 兜底
    return "minecraft:air", {}


def img_to_blocks_mcs(image: Image.Image, output: str, details: dict):
    """
    将图片映射为方块并直接写出 .mcstructure
    映射规则：像素 (x, y) -> 结构坐标 (x, 1, y)
    即落在 x–z 平面，Y 固定为 1
    """
    if Block is None or Structure is None:
        yield "ERROR: mcstructure 库未安装，请先 `pip install mcstructure`"
        return

    # —— 参数与默认值 —— 
    blocked_list = details.get('blocked_list', details.get('blocklist', []))
    mode = details.get('mode', 'All')
    _raw_cs = details.get('color_set')
    color_set = _raw_cs[0] if isinstance(_raw_cs, (list, tuple)) and _raw_cs else (_raw_cs or 'Linear Average')
    _raw_cc = details.get('color_compare')
    color_compare = _raw_cc[0] if isinstance(_raw_cc, (list, tuple)) and _raw_cc else (_raw_cc or 'Absolute Difference')

    # —— 色板/色差函数 —— 
    all_blocks_data = getattr(img_to_block_img, 'blocks_data', None)
    if all_blocks_data is None:
        yield "ERROR: 未能加载 blocks_data（请确认 img_to_blocks 模块内已初始化 blocks_data）"
        return
    dist_fn = getattr(img_to_block_img, 'color_compare_to_function', None)
    if dist_fn is None:
        yield "ERROR: 未找到 color_compare_to_function"
        return
    distance_function = dist_fn(color_compare)

    # 过滤清单
    if mode == "Whitelist":
        new_blocks_list = [b for b in all_blocks_data if b[0] in blocked_list]
    elif mode == "Blacklist":
        new_blocks_list = [b for b in all_blocks_data if b[0] not in blocked_list]
    else:
        new_blocks_list = all_blocks_data
    if not new_blocks_list:
        yield "ERROR"
        return

    # 像素 -> 方块（挑选最接近颜色的方块）
    def pix_to_block(pix):
        best_idx, best_diff = -1, math.inf
        # 为兼容旧资源，按常见顺序找可用面
        side_order = ('top','north','south','east','west','bottom')
        for idx, block_val in enumerate(new_blocks_list):
            chosen_side = next((s for s in side_order if s in block_val[1]), None)
            if not chosen_side:
                continue
            col = block_val[1][chosen_side]['color'].get(color_set)
            if col is None:
                continue
            diff = distance_function(pix, col)
            if diff < best_diff:
                best_diff = diff
                best_idx = idx
        if best_idx < 0:
            return "minecraft:air"
        return block_parser(new_blocks_list[best_idx][0])

    W, H = image.width, image.height

    # —— 关键：结构尺寸设为 (W, 2, H)，这样 y=1 才合法 —— 
    y_level = 1
    struct = Structure((W, y_level + 1, H), Block("minecraft:air"))

    # 写入：像素 (x,y) -> (x, 1, y)
    for x in range(W):
        for y in range(H):
            pix = image.getpixel((x, y))
            if isinstance(pix, (tuple, list)) and len(pix) >= 4 and pix[3] <= 10:
                continue
            blk_val = pix_to_block(pix)
            name, states = _parse_block_for_mcs(blk_val)
            if name == "minecraft:air" and not states:
                continue
            pos = (x, y_level, y)  # x,z 由像素 x,y 组成，y 固定为 1
            try:
                struct.set_block(pos, Block(name, **states))
            except Exception:
                pass
        yield x

    # 写出 .mcstructure
    head, tail = os.path.split(output)
    base = os.path.splitext(tail)[0] or "out"
    out_path = os.path.join(head or ".", base + ".mcstructure")
    try:
        with open(out_path, "wb") as f:
            struct.dump(f)
        yield "Done Processing!"
        yield "Done!"
    except Exception as e:
        yield f"ERROR: 写出 .mcstructure 失败: {e}"
    return

>>> src/logic/image_logic/every_pixel_generator.py
# THIS IS A PICKLE GENERATOR
# SHOULD ONLY BE USED IF YOU KNOW WHAT YOU ARE DOING
# THIS IS NOT PART OF THE PROGRAM YET


import json
import math
import pickle

from typing import Tuple, List

from PIL import Image

# TODO: Allow Pickle file, to speed up the image conversion
# ERROR: DOES NOT WORK
path = "../../../assets/blocks/all_blocks_textures/"
with open("../../../assets/blocks/img_generator_code/out.json", "r") as f:
    blocks_data: List = list(json.load(f).items())

blocks_img = {}
for block in blocks_data:
    for block_side in block[1].keys():
        if block_side == "extra":
            pass
        else:
            img = Image.open(path + block[1][block_side]['file'])
            blocks_img[block[0] + block_side] = img

new_block_list = blocks_data


def value_difference(x: Tuple, y: List) -> float:
    total_diff = 0
    for val1, val2 in zip(x, y):
        total_diff += abs(val1 - val2)

    return total_diff


side = 'bottom'


def pix_to_block_name(pix):
    all_differences = [
        (value_difference(pix, block_val[1][side]['color']) if (
                side in block_val[1]
        ) else math.inf)
        for block_val in new_block_list
    ]
    block_index = all_differences.index(min(all_differences))
    return new_block_list[block_index][0]


if __name__ == "__main__":
    data = {}

    for r in range(0, 256):
        for g in range(0, 256):
            for b in range(0, 256):
                data[(r, g, b)] = pix_to_block_name([r, g, b, 255])
        print(r)

    with open('rgb_bottom.pickle', 'wb') as f:
        pickle.dump(data, f)

>>> src/logic/image_logic/image_to_redstone_lamps.py
from PIL import Image, ImageFile
import mcschematic
import numpy as np
from src.path_manager.pather import resource_path

ImageFile.LOAD_TRUNCATED_IMAGES = True

# TODO: Allow all textures as binary options

lit_lamp = Image.open(resource_path("./assets/blocks/redstone_lamp_on.png"))
# noinspection PyTypeChecker
lit_lamp_np = np.array(lit_lamp.convert("RGB"))
unlit_lamp = Image.open(resource_path("./assets/blocks/redstone_lamp.png"))
# noinspection PyTypeChecker
unlit_lamp_np = np.array(unlit_lamp.convert("RGB"))


def img_to_redstone_lamps(
        img: Image.Image,
        brightness: int,
        dither: bool = False,
        alternate_mode: bool = False
):
    bw = [[]]
    if dither:
        bw = img.convert('1')
    if alternate_mode and not dither:
        gray = img.convert('L')
        # Let numpy do the heavy lifting for converting pixels to pure black or white
        bw = np.asarray(gray).copy()

        bw[bw < brightness] = 0  # Black
        bw[bw >= brightness] = 255  # White

    # Storing the new pixels in a numpy array, as it is a bit faster than Pil
    np_arr_test = np.zeros(shape=(img.height * 16, img.width * 16, 3), dtype=np.uint8)
    for x in range(0, img.width):
        for y in range(0, img.height):
            pos = [y * 16, x * 16]
            if dither:
                pixel = bw.getpixel((x, y))
                if pixel == 255:
                    np_arr_test[pos[0]:pos[0] + 16, pos[1]:pos[1] + 16] = lit_lamp_np
                else:
                    np_arr_test[pos[0]:pos[0] + 16, pos[1]:pos[1] + 16] = unlit_lamp_np
            else:
                # Getting the average brightness. If its over threshold, we use the lit redstone lamp
                if alternate_mode:
                    pixel = bw[y][x]
                    if pixel == 255:
                        np_arr_test[pos[0]:pos[0] + 16, pos[1]:pos[1] + 16] = lit_lamp_np
                    else:
                        np_arr_test[pos[0]:pos[0] + 16, pos[1]:pos[1] + 16] = unlit_lamp_np
                else:
                    pixel = img.getpixel((x, y))
                    avg_brightness = (pixel[0] + pixel[1] + pixel[2]) / 3
                    # Use lit redstone lap
                    if avg_brightness >= brightness:
                        np_arr_test[pos[0]:pos[0] + 16, pos[1]:pos[1] + 16] = lit_lamp_np
                    # Use unlit redstone lamp
                    else:
                        np_arr_test[pos[0]:pos[0] + 16, pos[1]:pos[1] + 16] = unlit_lamp_np
        yield x
    yield Image.fromarray(np_arr_test)
    return


def img_to_redstone_lamps_schem(
        img: Image.Image, brightness: int, place_redstone_blocks: bool,
        dither: bool = False, alternate_mode: bool = False
):
    schem = mcschematic.MCSchematic()
    bw = [[]]
    if dither:
        bw = img.convert('1')
    if alternate_mode and not dither:
        gray = img.convert('L')
        # Let numpy do the heavy lifting for converting pixels to pure black or white
        bw = np.asarray(gray).copy()

        bw[bw < brightness] = 0  # Black
        bw[bw >= brightness] = 255  # White

    for x in range(0, img.width):
        for y in range(0, img.height):
            if dither:
                pixel = bw.getpixel((x, y))
                if pixel == 255:
                    if place_redstone_blocks:
                        schem.setBlock((-x, 0, -y), "minecraft:redstone_lamp")
                        schem.setBlock((-x, -1, -y), "minecraft:redstone_block")
                    else:
                        schem.setBlock((-x, 0, -y), "minecraft:redstone_lamp[lit=true]")
                else:
                    schem.setBlock((-x, 0, -y), "minecraft:redstone_lamp")
            else:
                if alternate_mode:
                    pixel = bw[y][x]
                    if pixel == 255:
                        if place_redstone_blocks:
                            schem.setBlock((-x, 0, -y), "minecraft:redstone_lamp")
                            schem.setBlock((-x, -1, -y), "minecraft:redstone_block")
                        else:
                            schem.setBlock((-x, 0, -y), "minecraft:redstone_lamp[lit=true]")
                    else:
                        schem.setBlock((-x, 0, -y), "minecraft:redstone_lamp")
                else:
                    pixel = img.getpixel((x, y))
                    avg_brightness = (pixel[0] + pixel[1] + pixel[2]) / 3

                    # Use lit redstone lap
                    if avg_brightness >= brightness:
                        # new_img.paste(lit_lamp, (x * 16, y * 16))
                        if place_redstone_blocks:
                            schem.setBlock((-x, 0, -y), "minecraft:redstone_lamp")
                            schem.setBlock((-x, -1, -y), "minecraft:redstone_block")
                        else:
                            schem.setBlock((-x, 0, -y), "minecraft:redstone_lamp[lit=true]")
                    # Use unlit redstone lamp
                    else:
                        schem.setBlock((-x, 0, -y), "minecraft:redstone_lamp")
        yield x

    yield schem
    return

>>> src/logic/image_logic/img_to_blocks.py
import math
import mcschematic
import json
import functools
import numpy as np
from src.logic.image_logic.block_parser import block_parser
from PIL import Image, ImageFile
from src.path_manager.pather import resource_path
import os
from typing import TypedDict


class DetailsDict(TypedDict):
    side: str
    blocked_list: list
    mode: str
    color_set: str
    color_compare: str


ImageFile.LOAD_TRUNCATED_IMAGES = True

# TODO: ALTERNATE, A BIT DIFFERENT RENDERER
# TODO: INTERBLOCK PIXEL ACCOUNTER


# Loading the pre-generated blocks color
path = resource_path("./assets/blocks/all_blocks_textures/")
with open(resource_path("./assets/blocks/img_generator_code/out_all_colours.json"), "r") as f:
    blocks_data: list = list(json.load(f).items())

# Storing all the images in memory (as numpy arrays)
blocks_img_np = {}
for block in blocks_data:
    for block_side in block[1].keys():
        if block_side == "extra":
            pass
        else:
            img = Image.open(os.path.join(path, block[1][block_side]['file'])).convert("RGBA")
            # noinspection PyTypeChecker
            blocks_img_np[block[0] + block_side] = np.array(img)


def img_to_blocks(image: Image.Image, details: DetailsDict):
    side: str = details['side']
    blocked_list: list = details['blocked_list']
    mode: str = details['mode']
    color_set: str = details['color_set']
    color_compare: str = details['color_compare']
    # Storing the pixels data in numpy array as it is faster
    np_new_image = np.zeros(shape=(image.height * 16, image.width * 16, 4), dtype=np.uint8)

    # Filtering out the blocks, depending on how the user configured the options
    new_blocks_list = []
    if mode == "Whitelist":
        new_blocks_list = [selected_block for selected_block in blocks_data if selected_block[0] in blocked_list]
    elif mode == "Blacklist":
        new_blocks_list = [selected_block for selected_block in blocks_data if selected_block[0] not in blocked_list]
    else:
        new_blocks_list = blocks_data

    # If list is empty, we return
    if not new_blocks_list:
        yield Image.fromarray(np_new_image)
        return

    # This function is cached, to increase speed
    @functools.lru_cache(maxsize=100000)
    def pix_to_block(pix, distance_function: callable, avg_color_set: str):
        # The below statement becomes a list, with all the differences between the current pixel, and all the blocks
        all_differences = [
            (
                (
                    distance_function(pix, block_val[1][side]['color'][avg_color_set])
                ) if (side in block_val[1]) else math.inf
            ) for block_val in new_blocks_list
        ]
        # Getting the lowest different block
        block_index = all_differences.index(min(all_differences))
        block_img = blocks_img_np[new_blocks_list[block_index][0] + side]
        return block_img

    for x in range(0, image.width):
        for y in range(0, image.height):
            pos = (y * 16, x * 16)
            pixel = image.getpixel((x, y))
            if pixel[3] > 10:
                block_texture = pix_to_block(pixel, color_compare_to_function(color_compare), color_set)
                # Using numpy arrays because they are just faster
                np_new_image[pos[0]:pos[0] + 16, pos[1]:pos[1] + 16] = block_texture
        yield x

    yield Image.fromarray(np_new_image)
    return


def img_to_blocks_schem(image: Image.Image, details: DetailsDict):
    side: str = details['side']
    blocked_list: list = details['blocked_list']
    mode: str = details['mode']
    color_set: str = details['color_set']
    color_compare: str = details['color_compare']
    schem = mcschematic.MCSchematic()

    # Filtering out the blocks, depending on how the user configured the options
    new_blocks_list = []
    if mode == "Whitelist":
        new_blocks_list = [selected_block for selected_block in blocks_data if selected_block[0] in blocked_list]
    elif mode == "Blacklist":
        new_blocks_list = [selected_block for selected_block in blocks_data if selected_block[0] not in blocked_list]
    else:
        new_blocks_list = blocks_data

    if not new_blocks_list:
        yield "ERROR"
        return

    # Caching, for speed
    def pix_to_block(pix, distance_function: callable, avg_color_set: str):
        # The below statement becomes a list, with all the differences between the current pixel, and all the blocks
        all_differences = [
            (
                (
                    distance_function(pix, block_val[1][side]['color'][avg_color_set])
                ) if (side in block_val[1]) else math.inf
            ) for block_val in new_blocks_list
        ]
        # Getting the lowest different block
        block_index = all_differences.index(min(all_differences))
        block_data = block_parser(new_blocks_list[block_index][0])
        return block_data

    for x in range(0, image.width):
        for y in range(0, image.height):
            pixel = image.getpixel((x, y))
            block_name = pix_to_block(pixel, color_compare_to_function(color_compare), color_set)
            if side == "top" or side == "bottom":
                schem.setBlock((-x, 0, -y), block_name)
            else:
                schem.setBlock((-x, -y, 0), block_name)
        yield x

    yield schem
    return


# This is just to find which color function and color average to use
def color_compare_to_function(color_compare: str) -> callable:
    func = abs_value_difference
    if color_compare == "Euclidean Difference":
        func = euclidean_squared_difference
    elif color_compare == "Weighted Euclidean":
        func = weighted_euclidean_difference
    elif color_compare == "Redmean Difference":
        func = redmean_difference
    elif color_compare == "CIE76 DelE":
        func = cie76_del_e_difference
    return func


# Why tuple and list input? Laziness and performance

# Finds the difference in color between a pixel, and a block average colour
def abs_value_difference(x: tuple, y: list) -> float:
    total_diff = 0
    for val1, val2 in zip(x, y):
        total_diff += abs(val1 - val2)

    return total_diff


def euclidean_squared_difference(x: tuple, y: list) -> float:
    total_diff = 0
    for val1, val2 in zip(x, y):
        total_diff += (val1 - val2) ** 2

    return total_diff


# We shall ignore alpha difference, or be creative
def weighted_euclidean_difference(x: tuple, y: list) -> float:
    del_r = x[0] - y[0]
    del_g = x[1] - y[1]
    del_b = x[2] - y[2]
    alpha_diff = x[3] - y[3]
    r_bar = (x[0] + y[0]) / 2.0
    if r_bar < 128:
        return (2 * (del_r ** 2)) + (4 * (del_g ** 2)) + (3 * (del_b ** 2)) + alpha_diff ** 2
    else:
        return (3 * (del_r ** 2)) + (4 * (del_g ** 2)) + (2 * (del_b ** 2)) + alpha_diff ** 2


def redmean_difference(x: tuple, y: list) -> float:
    del_r = x[0] - y[0]
    del_g = x[1] - y[1]
    del_b = x[2] - y[2]
    r_bar = (x[0] + y[0]) / 2.0
    alpha_diff = x[3] - y[3]
    return (((2 + r_bar / 256) * (del_r ** 2))
            + (4 * (del_g ** 2))
            + ((2 + (255 - r_bar) / 256) * (del_b ** 2))
            + alpha_diff ** 2)


# Doe not account for alpha
def cie76_del_e_difference(x: tuple, y: list) -> float:
    x_no_alpha = [x[0], x[1], x[2]]
    y_no_alpha = [y[0], y[1], y[2]]

    Lab1 = rgb2lab(x_no_alpha)
    Lab2 = rgb2lab(y_no_alpha)

    total_diff = 0
    for val1, val2 in zip(Lab1, Lab2):
        total_diff += (val1 - val2) ** 2

    alpha_diff = x[3] - y[3]

    return total_diff + alpha_diff**2


# https://stackoverflow.com/a/16020102 and or http://www.easyrgb.com/en/math.php
# Remove alpha channel first!
def rgb2lab(input_color: tuple | list) -> list[int]:
    num = 0
    RGB = [0, 0, 0]

    for value in input_color:
        value = float(value) / 255

        if value > 0.04045:
            value = ((value + 0.055) / 1.055) ** 2.4
        else:
            value = value / 12.92

        RGB[num] = value * 100
        num = num + 1

    XYZ = [0, 0, 0, ]

    X = RGB[0] * 0.4124 + RGB[1] * 0.3576 + RGB[2] * 0.1805
    Y = RGB[0] * 0.2126 + RGB[1] * 0.7152 + RGB[2] * 0.0722
    Z = RGB[0] * 0.0193 + RGB[1] * 0.1192 + RGB[2] * 0.9505
    XYZ[0] = round(X, 4)
    XYZ[1] = round(Y, 4)
    XYZ[2] = round(Z, 4)

    XYZ[0] = float(XYZ[0]) / 95.047  # ref_X =  95.047   Observer= 2°, Illuminant= D65
    XYZ[1] = float(XYZ[1]) / 100.0  # ref_Y = 100.000
    XYZ[2] = float(XYZ[2]) / 108.883  # ref_Z = 108.883

    num = 0
    for value in XYZ:

        if value > 0.008856:
            value = value ** 0.3333333333333333
        else:
            value = (7.787 * value) + (16 / 116)

        XYZ[num] = value
        num = num + 1

    Lab = [0, 0, 0]

    L = (116 * XYZ[1]) - 16
    a = 500 * (XYZ[0] - XYZ[1])
    b = 200 * (XYZ[1] - XYZ[2])

    Lab[0] = round(L, 4)
    Lab[1] = round(a, 4)
    Lab[2] = round(b, 4)

    return Lab

# Maybe TODO: When compressing the image, instead of default compression however its done,
#        compress according to the color_averager module decided by user

>>> src/path_manager/pather.py
import os
import sys


def resource_path(relative_path):
    """ Get absolute path to resource, works for dev and for PyInstaller """
    try:
        # PyInstaller creates a temp folder and stores path in _MEIPASS
        base_path = sys._MEIPASS
    except Exception:
        base_path = os.path.abspath(".")
    return os.path.normpath(os.path.join(base_path, relative_path))

>>> src/window/window_layouts.py
from src.ui_manager import PySimpleGUI as sg
from src.window.layouts import imagetab, videotab, audiotab
from src.path_manager.pather import resource_path

# A custom decent theme
DecentGrey = {
    'BACKGROUND': '#303030',
    'TEXT': '#ffffff',
    'INPUT': '#404040',
    'TEXT_INPUT': '#ffffff',
    'SCROLL': '#707070',
    'BUTTON': ('#ffffff', '#505050'),
    'PROGRESS': ('#505F69', '#32414B'),
    'BORDER': 1, 'SLIDER_DEPTH': 0, 'PROGRESS_DEPTH': 0,
}
sg.theme_add_new('DecentGrey', DecentGrey)
sg.theme('DecentGrey')


def make_window():
    # Making sure the window size is alright
    # sg.Window.get_screen_size returns the actual screen size
    window_size = [1280, 720]
    if window_size[0] > sg.Window.get_screen_size()[0]:
        window_size[0] = sg.Window.get_screen_size()[0]

    if window_size[1] > sg.Window.get_screen_size()[1]:
        window_size[1] = sg.Window.get_screen_size()[1]

    # The layout for the Image Tab
    ITS_layout = imagetab.get_image_tab(window_size)
    # Layout for Video Tab
    VTS_layout = videotab.get_video_tab()
    # Layout for Audio Tab
    # TODO: AUDIO
    ATS_layout = audiotab.get_audio_tab()

    # TODO: SCHEMATIC RENDERER
    SCHEM_layout = [
        [
            sg.Text(text="Schematic Renderer")
        ],
        [
            sg.Text(text="This is unfinished!")
        ]
    ]

    # Joining all the layouts to one Layout
    layout = [
        [sg.Titlebar(
            title="IVAS-Maker",
            background_color="#2E2E2E",
            icon=resource_path("./assets/icon/IVASMaker_Icon_Tiny.png")
        )],
        # [sg.Col([[sg.Text("IVAS-Maker", text_color="#FFFFFF", background_color="#2E2E2E", grab=True)]],
        #         pad=(0, 0), background_color="#2e2e2e")],
        [
            sg.TabGroup([[
                sg.Tab('Image Stuff', ITS_layout),
                sg.Tab('Video Stuff', VTS_layout),
                sg.Tab('Audio Stuff', ATS_layout, key="-Audio_Tab-"),
                sg.Tab('Schematic Stuff', SCHEM_layout)
            ]])
        ],
        [
            sg.Button("QUIT!")
        ]
    ]

    # Loading the cool icon
    with open(resource_path("./assets/icon/icon_base64.txt"), "rb") as f:
        icon_base64 = f.read()

    # Note, I have commented out a few lines in PySimpleGUI.py
    # To make the icon stuff appear on taskbar
    # Find wm_overrideredirect there ig

    # Instantiating the window
    main_window = sg.Window(
        'IVAS-Maker', layout,
        size=(window_size[0], window_size[1]),
        background_color="#1E1E1E",
        icon=icon_base64,
    )
    return main_window

>>> src/window/layouts/audiotab.py
from src.ui_manager import PySimpleGUI as sg


def get_audio_tab() -> list:
    audio_tab_layout = [
        [sg.Frame(title="", layout=[
            [
                sg.Text(text="ATS!")
            ],
            [
                sg.Text(text="This is unfinished!")
            ],
            [
                sg.Text(text="Here is a button. Dont press it")
            ],
            [
                sg.Button(button_text="Button", key="-Audio_Easter_Egg-")
            ]], key="-Audio_Frame-")]
    ]
    return audio_tab_layout

>>> src/window/layouts/imagetab.py
from src.ui_manager import PySimpleGUI as sg
import textwrap
from src.path_manager.pather import resource_path
import json

# TODO: Black/white list will be all blocks name in a list, and clicking them changes colour to indicate its been
#  selected
path = resource_path("./assets/blocks/all_blocks_textures/")
with open(resource_path("./assets/blocks/img_generator_code/names_list.json"), "r") as f:
    blocks_data: list = list(json.load(f).keys())
    blocks_data.sort()


def get_image_tab(window_size: list[int]):
    # The attributes you can select for an image
    ITS_img_attributes = sg.Column([
        [

            sg.Text("Crop: "),
            sg.Input(key="-Img_Crop_Top_X-", tooltip="Top corner X", size=4, pad=0, enable_events=True),
            sg.Text(",", pad=0),
            sg.Input(key="-Img_Crop_Top_Y-", tooltip="Top corner Y", size=4, pad=0, enable_events=True),
            sg.Text(" To ", pad=0),
            sg.Input(key="-Img_Crop_Bottom_X-", tooltip="Top corner X", size=4, pad=0, enable_events=True),
            sg.Text(",", pad=0),
            sg.Input(key="-Img_Crop_Bottom_Y-", tooltip="Top corner Y", size=4, pad=0, enable_events=True),
            sg.Text(" ", pad=0)
        ],
        [
            sg.Text("Scale: "),
            sg.Combo(
                ['16x', '8x', '4x', '2x', '1x'], default_value="16x", key="-Img_Scale-",
                enable_events=True, readonly=True, background_color="#00000000"
            ),
            sg.Text(textwrap.fill("", width=50), key="-Img_Scale_Warning-")
        ],
        [
            sg.Text("Type: "),
            sg.Combo(
                [
                    "Image To Any Block Image",
                    "Image To Redstone Lamps Image",
                    "Image To Any Block Schematic",
                    "Image To Redstone Lamps Schematic"
                ], key="-Img_Type-",
                enable_events=True,
                default_value="Image To Redstone Lamps Image",
                readonly=True,
                background_color="#00000000"
            )
        ],
        [
            sg.Frame(
                title="Redstone Lamps Options",
                key="-Redstone_Lamps_Key-",
                layout=[
                    [
                        sg.Text("Brightness Required"),
                        sg.Slider(
                            range=(0, 255),
                            default_value=127,
                            orientation="horizontal",
                            key="-Image_Brightness-",
                            enable_events=True
                        )
                    ],
                    [
                        sg.Checkbox(
                            "Dithering",
                            tooltip="Dithering is useful in preserving details, but makes things look faded"
                                    "\nIt disables the brightness slider and alternate renderer checkbox",
                            key="-Img_Dithering-",
                            enable_events=True
                        )
                    ],
                    [
                        sg.Checkbox(
                            "Alternate Renderer",
                            tooltip="This one uses Pillow to convert to greyscale, "
                                    "\nthen filter out the dark and bright pixels",
                            key="-Img_Lamps_Alternate-",
                            enable_events=True
                        )
                    ],
                    [
                        sg.Checkbox("With power sources?", default=False, visible=False, key="-Img_Lamps_Schem_Check-")
                    ]
                ]
            ),
            sg.Frame(
                title="Any Block Image Attributes",
                key="-Any_Block_Key-",
                visible=False,
                layout=[
                    [
                        sg.Text("Blocks Blacklist/Whitelist"),
                        sg.Combo(
                            ["None", "Whitelist", "Blacklist"],
                            key="-Img_Any_Options-",
                            default_value="None",
                            readonly=True,
                            background_color="#00000000",
                            enable_events=True
                        ),
                    ],
                    [
                        sg.Text("Blocks side"),
                        sg.Combo(
                            ["Top", "Bottom", "Front", "Back", "Side"],
                            key="-Img_Any_Side-",
                            default_value="Top",
                            readonly=True,
                            background_color="#00000000",
                            enable_events=True
                        )
                    ],
                    [
                        sg.Text("Blocks List To Whitelist/Blacklist"),
                        sg.Listbox(
                            pad=(12, 2),
                            values=blocks_data,
                            select_mode=sg.LISTBOX_SELECT_MODE_MULTIPLE,
                            key="-Img_Any_Listing_List-",
                            size=(30, 10),
                            highlight_background_color="#00FF00",
                            enable_events=True,
                            right_click_menu=['&Right', ['Deselect All']]
                        ),
                    ],
                    [sg.Frame(title="Color Settings", layout=[
                        [
                            sg.Text(
                                "Average Color set (?)",
                                tooltip="These are the pre-computed color averages of each minecraft block, "
                                        "calculated in different ways",
                                text_color="#AAAAFF",
                                key="-Average_Colour_Popup-",
                                enable_events=True
                            ),
                            sg.Listbox([
                                "Linear Average",
                                "Root Mean Square Average",
                                "HSL Average",
                                "HSV Average",
                                "LAB Average",
                                "Dominant Color"
                            ], default_values=["Linear Average"], size=(20, 4), enable_events=True, key="-Color_Set-")
                        ],
                        [
                            sg.Text(
                                "Color Comparison Algorithm (?)",
                                tooltip="Changes how each individual pixel's rgb value is compared to "
                                        "each block's average color",
                                text_color="#AAAAFF",
                                key="-Color_Difference_Popup-",
                                enable_events=True
                            ),
                            sg.Listbox([
                                "Absolute Difference",
                                "Euclidean Difference",
                                "Weighted Euclidean",
                                "Redmean Difference",
                                "CIE76 DelE"
                            ], default_values=["Absolute Difference"], size=(20, 4), enable_events=True,
                                key="-Comparison_Method-")
                        ]
                    ])]
                ]
            )
        ],
        [
            sg.Text("Output: "),
            sg.Input(enable_events=True, key="-Output_Path-", size=30),
            sg.FileSaveAs("Save as",
                          key='-Img_Save_As_Img-',
                          file_types=(("Image Files", "*.png *.jpg"),),
                          target="-Output_Path-"
                          ),
            sg.FileSaveAs("Save as",
                          key='-Img_Save_As_Schem-',
                          file_types=(("Schematic Files", "*.schem"),),
                          visible=False,
                          target="-Output_Path-"
                          )
        ],
        [
            sg.Button("Run", key="-Img_Run-")
        ],
        [
            sg.Check("Update Preview?", default=True, key="-Update_Preview-")
        ],
        [
            sg.Text("Preview: (Renders at a low scale and \nno cropping and decreased resolution)")
        ],
        [
            sg.Image(key="-Preview_Image-")
        ],
        [
            sg.Text("May not be what you see when the image is rendered", size=(40, 10))
        ]
    ], key="-Img_Attrs-", visible=False, scrollable=True, size=(int(window_size[0] / 1.4), int(window_size[1] / 1.2)))

    # The area to load the image
    ITS_imageloader = sg.Column([
        [
            sg.Text(text="HI!")
        ],
        [sg.Text('Filename')],
        [
            sg.Input(enable_events=True, key="-Text Entered-"),
            sg.FileBrowse(tooltip="Browse for an Image", file_types=(("Image Files", "*.png;*.jpg;*.jpeg;*.bmp"),))
        ],
        [sg.Button("Load", disabled=True, key="-Submit_ITS-")],
        [sg.Image(key="-LOADED_IMAGE-", visible=False)]
    ])

    # The full image tab layout
    ITS_layout = [[
        ITS_imageloader, sg.VerticalSeparator(), ITS_img_attributes
    ]]

    return ITS_layout

>>> src/window/layouts/videotab.py
from src.ui_manager import PySimpleGUI as sg
import textwrap
from src.path_manager.pather import resource_path
import json

path = resource_path("./assets/blocks/all_blocks_textures/")
with open(resource_path("./assets/blocks/img_generator_code/names_list.json"), "r") as f:
    blocks_data: list = list(json.load(f).keys())
    blocks_data.sort()


def get_video_tab():
    # The attributes you can select for the video
    VTS_vid_attributes = sg.Column([
        [
            sg.Text("Loaded Video: ", key="-Vid_Loaded-")
        ],
        [
            sg.Text("Frame rate: "),
            sg.Slider(
                (0.1, 150),
                default_value=60, key="-Vid_Frame_Rate-", orientation="horizontal", resolution=0.1, enable_events=True
            ),
            sg.Text("Frame Count: ", key='-Frame_Count-')
        ],
        [
            sg.Text("Scale: "),
            sg.Combo(
                ['16x', '8x', '4x', '2x', '1x'], default_value="16x", key="-Vid_Scale-",
                enable_events=True, readonly=True, background_color="#00000000"
            ),
            sg.Text(
                textwrap.fill("", width=50),
                visible=True, text_color="#FF1111", key="-Vid_Scale_Warning-"
            )
        ],
        [
            sg.Checkbox("Retain Quality?", key='-Vid_Quality-'),
            sg.T("A bit slower, and more cache storage taken")
        ],
        [
            sg.Text("Type: "),
            sg.Combo(
                [
                    "Video To Any Block Video",
                    "Video To Redstone Lamps Video",
                    # These two later
                    # "Video To Any Block Schematic",
                    # "Video To Redstone Lamps Schematic"
                ], key="-Vid_Type-",
                enable_events=True,
                default_value="Video To Redstone Lamps Video",
                readonly=True,
                background_color="#00000000"
            )
        ],
        [
            sg.Frame(title="Redstone Lamps Options", layout=[
                [
                    sg.Text("Brightness Required", key="-Vid_List_Text-"),
                    sg.Slider(
                        range=(0, 255),
                        default_value=127,
                        orientation="horizontal",
                        key="-Vid_Brightness-"
                    )
                ],
                [
                    sg.Checkbox(
                        "Dithering",
                        tooltip="Dithering is useful in preserving details, but makes things look faded"
                                "\nIt disables the brightness slider and alternate renderer checkbox",
                        key="-Vid_Dithering-"
                    )
                ],
                [
                    sg.Checkbox(
                        "Alternate Renderer",
                        tooltip="This one uses Pillow to convert to greyscale, "
                                "\nthen filter out the dark and bright pixels",
                        key="-Vid_Lamps_Alternate-"
                    )
                ],
            ], key="-Vid_Redstone_Lamps_Key-"
            ),
            sg.Frame(title="Any Block Image Attributes", layout=[
                [
                    sg.Text("Blocks Blacklist/Whitelist"),
                    sg.Combo(
                        ["None", "Whitelist", "Blacklist"],
                        key="-Vid_Any_Options-",
                        default_value="None",
                        readonly=True,
                        background_color="#00000000"
                    ),
                ],
                [
                    sg.Text("Blocks side"),
                    sg.Combo(
                        ["Top", "Bottom", "Front", "Back", "Side"],
                        key="-Vid_Any_Side-",
                        default_value="Top",
                        readonly=True,
                        background_color="#00000000"
                    )
                ],
                [
                    sg.Text("Blocks List"),
                    sg.Listbox(
                        values=blocks_data,
                        pad=(12, 2),
                        select_mode=sg.LISTBOX_SELECT_MODE_MULTIPLE,
                        key="-Vid_Any_Listing_List-",
                        size=(30, 10),
                        highlight_background_color="#00FF00",
                        right_click_menu=['&Right', ['Deselect All']]
                    ),
                ],
                [sg.Frame(title="Color Settings", layout=[
                    [
                        sg.Text(
                            "Average Color set (?)",
                            tooltip="These are the pre-computed color averages of each minecraft block, "
                                    "calculated in different ways",
                            text_color="#AAAAFF",
                            key="-Vid_Average_Colour_Popup-",
                            enable_events=True
                        ),
                        sg.Listbox([
                            "Linear Average",
                            "Root Mean Square Average",
                            "HSL Average",
                            "HSV Average",
                            "LAB Average",
                            "Dominant Color"
                        ], default_values=["Linear Average"], size=(20, 4), key="-Vid_Color_Set-")
                    ],
                    [
                        sg.Text(
                            "Color Comparison Algorithm (?)",
                            tooltip="Changes how each individual pixel's rgb value is compared to "
                                    "each block's average color",
                            text_color="#AAAAFF",
                            key="-Vid_Color_Difference_Popup-",
                            enable_events=True
                        ),
                        sg.Listbox([
                            "Absolute Difference",
                            "Euclidean Difference",
                            "Weighted Euclidean",
                            "Redmean Difference",
                            "CIE76 DelE"
                        ], default_values=["Absolute Difference"], size=(20, 4), key="-Vid_Comparison_Method-")
                    ]
                ])]
            ], key="-Vid_Any_Block_Key-", visible=False),
        ],
        [
            sg.Text("Output: "),
            sg.Input(enable_events=True, key="-Vid_Output_Path-", size=30),
            sg.FileSaveAs("Save as", file_types=(("Video Files", "*.mp4"),))
        ],
        [sg.Text("Advance Options ∧", key="-Advance_Dropdown-", enable_events=True)],
        [
            sg.Column([
                [
                    sg.Text("Process Count"), sg.Spin(
                        [i+1 for i in range(16)],
                        initial_value=2,
                        key="-Process_Count-",
                    ),
                    sg.Text("May cause issues\nwith high process counts.")
                ],
            ], visible=False, key='-Advance_Options-')
        ],
        [
            sg.Button("Run", key="-Vid_Run-")
        ],
        [
            sg.T("", size=(1, 12))
        ]
    ], key="-Vid_Attrs-", visible=False, scrollable=True, size=(500, 350))

    # Progress meters to check the video's conversion progress
    Progress_Meters = sg.Column([
        [sg.T("Video Image Conversion")],
        [sg.Progress(max_value=2, orientation='horizontal', size=(20, 10), key='-Images_Vid_Conversion-')],
        [sg.T("Frames Converted")],
        [
            sg.Progress(max_value=100, orientation='horizontal', size=(20, 10), key='-Number_Of_Frames-'),
            sg.Text("0/0", key="-Number_Of_Frames_Text-")
        ],
        [sg.T("Singular Frame Progress")],
        [sg.Progress(max_value=100, orientation='horizontal', size=(20, 10), key='-Single_Frame-')],
        [sg.Image(size=(50, 50), key='-Progress_Gif-')]
    ], key='-Vid_Progress_Meters-', visible=False)

    # The area to load the Video
    VTS_Videoloader = sg.Column([
        [
            sg.Text(text="HI!")
        ],
        [sg.Text('Filename')],
        [
            sg.Input(enable_events=True, key="-Vid Text Entered-"),
            sg.FileBrowse(tooltip="Browse for an Video", file_types=(("Video Files", "*.mp4;*.mpeg;*.mkv"),))
        ],
        [sg.Button("Load", disabled=True, key="-Submit_VTS-")],
        [
            sg.HorizontalSeparator()
        ],
        [
            Progress_Meters
        ]

    ])

    # The full video tab layout
    VTS_layout = [[
        VTS_Videoloader, sg.VerticalSeparator(), VTS_vid_attributes
    ]]

    return VTS_layout

